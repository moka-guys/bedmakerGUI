<summary>

<header>
Repopack Output File
This file was generated by Repopack on: 2024-12-02T11:52:52.754Z
</header>

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository structure
3. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the file path attributes to distinguish
  between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation.


</notes>

<additional_info>
For more information about Repopack, visit: https://github.com/yamadashy/repopack
</additional_info>

</summary>

<repository_structure>
app/
  auth/
    __init__.py
    forms.py
    routes.py
  bed_generator/
    __init__.py
    api.py
    bed_generator.py
    database.py
    debug.py
    logic.py
    routes.py
    utils.py
  bed_manager/
    __init__.py
    routes.py
  static/
    js/
      bed_generator.js
      results.js
  templates/
    auth/
      login.html
      user_management.html
    bed_manager/
      bed_file_details.html
      index.html
    base.html
    bed_generator.html
    results.html
    settings.html
  __init__.py
  extensions.py
  forms.py
  models.py
migrations/
  versions/
    03052354c8b6_add_utr_settings_for_bed_types.py
    2363d18d116a_add_role_column_to_user_table.py
    3467b49b34cd_add_snp_padding_settings.py
    35d6835fbaf8_add_utr_inclusion_columns_to_bedfile.py
    4ee76151a4b6_add_initial_query_to_bedfile.py
    6a06a48e6f48_add_exporttype_model_and_update_settings.py
    6ed3cbad7b03_add_assembly_column_to_bed_file_table.py
    85f66015e00d_add_snp_padding_fields.py
    a082711d385e_add_warning_column_to_bed_file_table.py
    b42377b4f699_add_utr_settings_for_bed_types.py
    c73425212377_update_settings_structure.py
    ebb20169be05_change_warning_to_status_in_bedentry.py
  alembic.ini
  env.py
  README
  script.py.mako
.dockerignore
.gitignore
backup.py
config.py
create_user.py
docker-compose.yml
Dockerfile
entrypoint.sh
migration.py
README.md
run.py
</repository_structure>

<repository_files>

<file path="app/auth/__init__.py">
from flask import Blueprint

auth_bp = Blueprint('auth', __name__)

from app.auth import routes

# Import Flask-Login
from flask_login import LoginManager

# Create LoginManager instance
login_manager = LoginManager()
login_manager.login_view = 'auth.login'
login_manager.login_message_category = 'info'

# User loader function
@login_manager.user_loader
def load_user(user_id):
    from app.models import User
    return User.query.get(int(user_id))
</file>

<file path="app/auth/forms.py">
from flask_wtf import FlaskForm
from wtforms import StringField, PasswordField, SubmitField
from wtforms.validators import DataRequired, Email, EqualTo

class LoginForm(FlaskForm):
    username = StringField('Username', validators=[DataRequired()])
    password = PasswordField('Password', validators=[DataRequired()])
    submit = SubmitField('Sign In')

class RegistrationForm(FlaskForm):
    username = StringField('Username', validators=[DataRequired()])
    email = StringField('Email', validators=[DataRequired(), Email()])
    password = PasswordField('Password', validators=[DataRequired()])
    password2 = PasswordField('Repeat Password', validators=[DataRequired(), EqualTo('password')])
    submit = SubmitField('Register')
</file>

<file path="app/auth/routes.py">
"""
routes.py - Defines the authentication and user management routes for the application.

Routes:
- set_authorizer(user_id): Sets or removes authorizer status for a user.
- user_management(): Displays the user management page for authorizers.
- create_user(): Handles the creation of new users.
- login(): Manages user login.
- logout(): Handles user logout.
- settings(): Displays and updates application settings.
"""

from flask import render_template, redirect, url_for, flash, request
from flask_login import login_user, logout_user, login_required, current_user
from app.auth import auth_bp
from app.models import User, Settings
from app import db
from urllib.parse import urlparse
from app.auth.forms import LoginForm, RegistrationForm

@auth_bp.route('/set_authorizer/<int:user_id>', methods=['POST'])
@login_required
def set_authorizer(user_id):
    if not current_user.is_authorizer:
        flash('You do not have permission to perform this action.', 'error')
        return redirect(url_for('auth.user_management'))

    user = User.query.get_or_404(user_id)
    is_authorizer = request.form.get('is_authorizer') == 'true'

    user.is_authorizer = is_authorizer
    db.session.commit()

    action = 'set' if is_authorizer else 'removed'
    flash(f"User {user.username}'s authorizer status has been {action}.", 'success')
    return redirect(url_for('auth.user_management'))

@auth_bp.route('/user_management')
@login_required
def user_management():
    if not current_user.is_authorizer:
        flash('You do not have permission to access this page.', 'error')
        return redirect(url_for('bed_manager.index'))

    users = User.query.all()
    return render_template('auth/user_management.html', users=users)

@auth_bp.route('/create_user', methods=['POST'])
@login_required
def create_user():
    if not current_user.is_authorizer:
        flash('You do not have permission to create users.', 'error')
        return redirect(url_for('auth.user_management'))

    username = request.form.get('username')
    email = request.form.get('email')
    password = request.form.get('password')
    is_authorizer = 'is_authorizer' in request.form
    role = request.form.get('role')

    if User.query.filter_by(username=username).first():
        flash('Username already exists.', 'error')
        return redirect(url_for('auth.user_management'))

    if User.query.filter_by(email=email).first():
        flash('Email already exists.', 'error')
        return redirect(url_for('auth.user_management'))

    new_user = User(username=username, email=email, is_authorizer=is_authorizer, role=role)
    new_user.set_password(password)

    db.session.add(new_user)
    db.session.commit()

    flash(f'User {username} has been created successfully.', 'success')
    return redirect(url_for('auth.user_management'))

@auth_bp.route('/login', methods=['GET', 'POST'])
def login():
    if current_user.is_authenticated:
        return redirect(url_for('main.index'))
    form = LoginForm()
    if form.validate_on_submit():
        user = User.query.filter_by(username=form.username.data).first()
        if user is None or not user.check_password(form.password.data):
            flash('Invalid username or password', 'danger')
            return redirect(url_for('auth.login'))
        login_user(user)
        next_page = request.args.get('next')
        if not next_page or urlparse(next_page).netloc != '':
            next_page = url_for('main.index')
        return redirect(next_page)
    return render_template('auth/login.html', title='Sign In', form=form)

@auth_bp.route('/logout')
def logout():
    logout_user()
    return redirect(url_for('main.index'))

@auth_bp.route('/register', methods=['GET', 'POST'])
def register():
    if current_user.is_authenticated:
        return redirect(url_for('main.index'))
    form = RegistrationForm()
    if form.validate_on_submit():
        user = User(username=form.username.data, email=form.email.data)
        user.set_password(form.password.data)
        db.session.add(user)
        db.session.commit()
        flash('Congratulations, you are now a registered user!', 'success')
        return redirect(url_for('auth.login'))
    return render_template('auth/register.html', title='Register', form=form)
</file>

<file path="app/bed_generator/__init__.py">
from flask import Blueprint

bed_generator_bp = Blueprint('bed_generator', __name__)

from app.bed_generator import routes
</file>

<file path="app/bed_generator/api.py">
"""
api.py - Fetches and processes variant information from Ensembl, TARK, and PanelApp APIs.

Functions:
- fetch_variant_info: Retrieves variant information from the Ensembl API using a given rsID and assembly.
- fetch_data_from_tark: Fetches transcript data from the TARK API based on an identifier and assembly.
- fetch_data_from_tark_with_hg38: Retrieves GRCh37 transcript data using a GRCh38 identifier.
- fetch_coordinate_info: Obtains gene overlap information for a given genomic coordinate.
- fetch_panels_from_panelapp: Retrieves signed-off gene panels from the PanelApp API.
- fetch_genes_for_panel: Fetches genes associated with a specific panel from PanelApp, filtered by confidence level.
- validate_coordinates: Validates the format of genomic coordinates from frontend.
"""

import requests
import re
from typing import Dict, List, Optional
import time
import logging
from dataclasses import dataclass
import concurrent.futures

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Constants
ENSEMBL_GRCh38_URL = "https://rest.ensembl.org"
ENSEMBL_GRCh37_URL = "https://grch37.rest.ensembl.org"
TARK_API_URL = "https://tark.ensembl.org/api/"
PANELAPP_API_URL = "https://panelapp.genomicsengland.co.uk/api/v1/"

# Helper functions
def get_ensembl_url(assembly: str) -> str:
    """Returns the appropriate Ensembl API URL based on the given assembly version."""
    return ENSEMBL_GRCh38_URL if assembly == 'GRCh38' else ENSEMBL_GRCh37_URL

class ApiError(Exception):
    pass

class ApiClient:
    @staticmethod
    def make_api_request(url: str, params: Optional[Dict] = None, retries: int = 3) -> Optional[Dict]:
        """
        Makes a GET request to the specified URL with optional parameters and returns the JSON response.
        Implements a retry mechanism with exponential backoff for handling rate limits and server errors.

        Args:
            url (str): The URL to send the GET request to.
            params (Optional[Dict]): A dictionary of query parameters to include in the request.
            retries (int): The number of retry attempts for handling errors.

        Returns:
            Optional[Dict]: The JSON response from the API if the request is successful, otherwise None.
        """
        attempt = 0
        while attempt < retries:  # Changed from <= to < to match actual retry count
            try:
                response = requests.get(url, params=params)
                response.raise_for_status()
                return response.json()
            except requests.exceptions.HTTPError as e:
                if response.status_code in [429, 500, 502, 503, 504]:
                    attempt += 1
                    wait_time = 2 ** attempt  # Exponential backoff
                    logger.warning(f"API request failed with status {response.status_code}. "
                                 f"Attempt {attempt}/{retries}. "
                                 f"Retrying in {wait_time} seconds...")
                    time.sleep(wait_time)
                    if attempt == retries:
                        logger.error(f"Max retries exceeded for URL: {url}")
                        return None
                else:
                    logger.error(f"API request failed with status {response.status_code}: {e}")
                    return None
            except requests.exceptions.RequestException as e:
                logger.error(f"Request failed: {e}")
                return None
            except Exception as e:
                logger.error(f"Unexpected error: {e}")
                return None
        
        return None

    @classmethod
    def get_ensembl_data(cls, url: str) -> Optional[Dict]:
        return cls.make_api_request(url)

    @classmethod
    def get_tark_data(cls, url: str, params: Dict) -> Optional[Dict]:
        return cls.make_api_request(url, params)

    @classmethod
    def get_panelapp_data(cls, url: str) -> Optional[Dict]:
        return cls.make_api_request(url)

# Main functions
@dataclass
class VariantInfo:
    rsid: str
    accession: str
    gene: str
    entrez_id: str
    loc_region: str
    loc_start: int
    loc_end: int
    allele_string: str
    most_severe_consequence: str
    transcript_biotype: str

def fetch_variant_info(rsid: str, assembly: str) -> Optional[VariantInfo]:
    """
    Fetches variant information from the Ensembl API using a given rsID and assembly.

    Args:
        rsid (str): The reference SNP ID (rsID) of the variant.
        assembly (str): The genome assembly version ('GRCh38' or 'GRCh37').

    Returns:
        Optional[VariantInfo]: A dataclass containing variant information if successful, otherwise None.
    """
    logger.info(f"Fetching variant info for {rsid} using assembly {assembly}")
    ensembl_url = f"{get_ensembl_url(assembly)}/vep/human/id/{rsid}?merged=true&content-type=application/json"
    
    # Makes the API request and checks if data is returned.
    data = ApiClient.get_ensembl_data(ensembl_url)
    if not data:
        return None

    # Extracts the first variant from the response and looks for RefSeq transcript consequences.
    variant = data[0]
    transcript_consequences = variant.get('transcript_consequences', [])
    refseq_consequence = next((c for c in transcript_consequences if c.get('source') == 'RefSeq'), None)

    # Returns a dataclass with variant details, using 'unknown' as a default for missing data.
    return VariantInfo(
        rsid=rsid,
        accession=refseq_consequence.get('transcript_id', 'unknown') if refseq_consequence else 'unknown',
        gene=refseq_consequence.get('gene_symbol', 'unknown') if refseq_consequence else 'unknown',
        entrez_id=refseq_consequence.get('hgnc_id', 'unknown') if refseq_consequence else 'unknown',
        loc_region=variant.get('seq_region_name', 'unknown'),
        loc_start=variant.get('start', 0),
        loc_end=variant.get('end', 0),
        allele_string=variant.get('allele_string', 'unknown'),
        most_severe_consequence=variant.get('most_severe_consequence', 'unknown'),
        transcript_biotype=refseq_consequence.get('consequence_terms', ['unknown'])[0] if refseq_consequence else 'unknown'
    )

def fetch_data_from_tark(identifier: str, assembly: str) -> Optional[List[Dict]]:
    """
    Fetches transcript data from TARK API with optimized request handling and parallel processing.
    """
    print(f"\n=== Fetching data for identifier: {identifier} ===")
    base_accession = identifier.split('.')[0]
    version = identifier.split('.')[1] if '.' in identifier else None
    
    search_url = f"{TARK_API_URL}transcript/search/"
    params = {
        'identifier_field': base_accession,
        'expand': 'exons,genes',
        'assembly_name': 'GRCh38' if assembly == 'GRCh38' else 'GRCh37'
    }
    
    # Make a single API call to get all transcript data
    data = ApiClient.get_tark_data(search_url, params)
    print(f"Initial TARK search result: {bool(data)}")
    
    # If we're looking for GRCh37 and either no data found or no GRCh37 transcripts
    if assembly == 'GRCh37' and (not data or not any(t for t in data if t['assembly'] == 'GRCh37')):
        # Try Ensembl gene symbol lookup as fallback
        ensembl_url = f"https://rest.ensembl.org/xrefs/symbol/homo_sapiens/{identifier}?content-type=application/json"
        print(f"Trying Ensembl lookup URL: {ensembl_url}")
        ensembl_data = ApiClient.get_ensembl_data(ensembl_url)
        print(f"Ensembl lookup response: {ensembl_data}")
        
        if ensembl_data and len(ensembl_data) > 0:
            ensembl_id = ensembl_data[0].get('id')
            print(f"Found Ensembl ID: {ensembl_id}")
            if ensembl_id:
                # Try TARK search with Ensembl ID
                params['identifier_field'] = ensembl_id
                print(f"Trying TARK search with Ensembl ID. URL: {search_url}, Params: {params}")
                new_data = ApiClient.get_tark_data(search_url, params)
                print(f"TARK search with Ensembl ID result: {bool(new_data)}")
                if new_data:
                    logger.info(f"Found transcript data using Ensembl ID lookup for {identifier}")
                    # Add warning about using Ensembl ID lookup
                    for transcript in new_data:
                        transcript['warning'] = {
                            'message': f"Transcript found via Ensembl gene symbol lookup - clinical review recommended",
                            'identifier': identifier,
                            'type': 'ensembl_lookup'
                        }
                    data = new_data

    if not data or (assembly == 'GRCh37' and not any(t for t in data if t['assembly'] == 'GRCh37')):
        print("No data found after all attempts")
        return None
        
    # Filter and process transcripts based on assembly and version
    transcripts = select_transcripts(data, assembly, version)
    
    # If no transcripts found for GRCh37, try parallel processing of alternatives
    if not transcripts and assembly == 'GRCh37':
        with concurrent.futures.ThreadPoolExecutor(max_workers=2) as executor:
            futures = []
            
            # Try finding matching GRCh38 MANE SELECT
            futures.append(executor.submit(
                process_grch38_mane_select,
                data, base_accession, identifier
            ))
            
            # Try with base accession in parallel
            futures.append(executor.submit(
                process_base_accession,
                data, base_accession, identifier
            ))
            
            # Use the first successful result
            for future in concurrent.futures.as_completed(futures):
                try:
                    result = future.result()
                    if result:
                        return result
                except Exception as e:
                    logger.error(f"Error in parallel processing: {e}")
                    continue
    
    return process_transcripts(transcripts, base_accession)

def process_grch38_mane_select(data: List[Dict], base_accession: str, identifier: str) -> Optional[List[Dict]]:
    """Helper function to process GRCh38 MANE SELECT transcripts."""
    grch38_transcripts = [t for t in data if t['assembly'] == 'GRCh38']
    mane_select = next((t for t in grch38_transcripts 
                      if t.get('mane_transcript_type') == 'MANE SELECT'), None)
    
    if mane_select:
        warning = {
            'message': f"No direct GRCh37 transcript found. Using GRCh38 MANE SELECT transcript {mane_select['stable_id']} to find matching GRCh37 version",
            'identifier': identifier,
            'type': 'assembly_mapping'
        }
        matching_grch37 = [t for t in data 
                         if t['assembly'] == 'GRCh37' 
                         and t['stable_id'] == mane_select['stable_id']]
        
        if matching_grch37:
            selected = max(matching_grch37, 
                         key=lambda x: int(x.get('stable_id_version', 0)))
            selected['warning'] = warning
            return process_transcripts([selected], base_accession)
    return None

def process_base_accession(data: List[Dict], base_accession: str, identifier: str) -> Optional[List[Dict]]:
    """Helper function to process base accession transcripts."""
    warning = {
        'message': "No MANE SELECT transcript found. Using base accession for GRCh37 lookup - clinical review recommended",
        'identifier': identifier,
        'type': 'assembly_mapping'
    }
    grch37_transcripts = [t for t in data if t['assembly'] == 'GRCh37']
    if grch37_transcripts:
        selected = max(grch37_transcripts, 
                     key=lambda x: int(x.get('stable_id_version', 0)))
        selected['warning'] = warning
        return process_transcripts([selected], base_accession)
    return None

def select_transcripts(data: List[Dict], assembly: str, version: Optional[str] = None) -> List[Dict]:
    """
    Selects the most relevant transcripts from the provided data based on the assembly and version.
    """
    # Filters transcripts based on assembly and stable ID prefix (NM or NR).
    assembly_transcripts = [item for item in data if item['assembly'] == assembly and (item['stable_id'].startswith('NM') or item['stable_id'].startswith('NR'))]
    
    # If version is specified, filter for exact version match
    if version:
        versioned_transcripts = [t for t in assembly_transcripts if str(t['stable_id_version']) == version]
        if versioned_transcripts:
            selected = versioned_transcripts[0]
            identifier = f"{selected['stable_id']}.{selected['stable_id_version']}"
            # Only add warning if this is a user-specified version
            if '.' in identifier:  # This indicates user specified a version
                selected['warning'] = {
                    'message': "Version specified by user",
                    'identifier': identifier,
                    'type': 'version_specified'
                }
            selected.pop('mane_transcript_type', None)
            return [selected]

    if assembly == 'GRCh38':
        # Prioritises MANE transcripts if available for GRCh38.
        mane_transcripts = [t for t in assembly_transcripts if t.get('mane_transcript_type') in ['MANE PLUS CLINICAL', 'MANE SELECT']]
        if mane_transcripts:
            return mane_transcripts
    elif assembly == 'GRCh37':
        # For GRCh37, find the corresponding MANE transcript in GRCh38 to ensure consistency
        grch38_mane = next((t for t in data if t['assembly'] == 'GRCh38' and 
                            t.get('mane_transcript_type') in ['MANE PLUS CLINICAL', 'MANE SELECT'] and 
                            t['stable_id'].startswith('NM')), None)
        if grch38_mane:
            matching_grch37 = [t for t in assembly_transcripts if t['stable_id'] == grch38_mane['stable_id']]
            if matching_grch37:
                selected = max(matching_grch37, key=lambda x: int(x['stable_id_version']))
                identifier = f"{selected['stable_id']}.{selected['stable_id_version']}"
                selected['warning'] = {
                    'message': f"Transcript selected based on GRCh38 MANE transcript {grch38_mane['stable_id']}.{grch38_mane['stable_id_version']}",
                    'identifier': identifier,
                    'type': 'transcript_selection'
                }
                return [selected]

    # If no MANE transcripts or matching GRCh37 transcript
    if assembly_transcripts:
        # Add null check and default to 0 if version is missing or invalid
        def get_version(transcript):
            try:
                return int(transcript.get('stable_id_version', 0))
            except (TypeError, ValueError):
                return 0
                
        selected = max(assembly_transcripts, key=get_version)
        identifier = f"{selected['stable_id']}.{selected['stable_id_version']}"
        selected['warning'] = {
            'message': "No MANE transcript available. Selected highest version number - clinical review recommended",
            'identifier': identifier,
            'type': 'transcript_selection'
        }
        return [selected]
    
    return []

def process_transcripts(transcripts: List[Dict], identifier: str) -> List[Dict]:
    results = []
    for transcript in transcripts:
        if not transcript:
            continue

        print(f"\nProcessing transcript: {transcript.get('stable_id')}")
        print(f"Assembly: {transcript.get('assembly')}")
        
        # Get Ensembl ID and Entrez ID from genes data
        ensembl_id = None
        entrez_id = None
        if transcript.get('genes'):
            for gene in transcript['genes']:
                if gene.get('ensembl_id'):
                    ensembl_id = gene['ensembl_id']
                    entrez_id = gene['ensembl_id']
                    break
                elif gene.get('stable_id'):
                    ensembl_id = gene['stable_id']
                    entrez_id = gene['stable_id']
                    break

        # Handle MANE transcript and type based on assembly
        assembly = transcript.get('assembly')
        mane_transcript = ''
        mane_transcript_type = None
        if assembly == 'GRCh38':
            mane_transcript = transcript.get('mane_transcript', '')
            mane_transcript_type = transcript.get('mane_transcript_type', '')
        
        print(f"Found Ensembl ID from genes: {ensembl_id}")
        print(f"Found Entrez ID from genes: {entrez_id}")
        print(f"MANE transcript (only for GRCh38): {mane_transcript}")
        print(f"MANE transcript type (only for GRCh38): {mane_transcript_type}")

        # Build the result dictionary
        for index, exon in enumerate(transcript.get('exons', []), start=1):
            result = {
                'loc_region': exon['loc_region'],
                'loc_start': exon['loc_start'],
                'loc_end': exon['loc_end'],
                'loc_strand': exon['loc_strand'],
                'accession': f"{transcript['stable_id']}.{transcript['stable_id_version']}",
                'ensembl_id': ensembl_id,
                'gene': next((gene['name'] for gene in transcript.get('genes', []) if gene['name']), identifier),
                'entrez_id': entrez_id,
                'exon_id': exon['stable_id'],
                'exon_number': index,
                'transcript_biotype': transcript.get('biotype', ''),
                'mane_transcript': mane_transcript,
                'mane_transcript_type': mane_transcript_type,
                'status': None,  # Initialize status as None
                'identifier': identifier,
                'five_prime_utr': {
                    'start': transcript.get('five_prime_utr_start'),
                    'end': transcript.get('five_prime_utr_end')
                },
                'three_prime_utr': {
                    'start': transcript.get('three_prime_utr_start'),
                    'end': transcript.get('three_prime_utr_end')
                }
            }
            
            # Set status based on MANE type if present, handling case-insensitively
            if mane_transcript_type:
                mane_type_upper = mane_transcript_type.upper()
                if mane_type_upper == 'MANE SELECT':
                    result['status'] = 'MANE Select transcript'
                elif mane_type_upper == 'MANE PLUS CLINICAL':
                    result['status'] = 'MANE Plus Clinical transcript'
            elif transcript.get('warning'):
                result['status'] = transcript['warning'].get('message') if isinstance(transcript['warning'], dict) else transcript['warning']
            
            results.append(result)

        print(f"Final result for transcript: {results[-1]}")

    return results

def fetch_data_from_tark_with_hg38(hg38_identifier: str, warning: Optional[Dict] = None) -> Optional[List[Dict]]:
    """
    Retrieves GRCh37 transcript data using a GRCh38 identifier.

    Args:
        hg38_identifier (str): The GRCh38 identifier for the transcript.
        warning (Optional[Dict]): Warning to propagate to the results.

    Returns:
        Optional[List[Dict]]: A list of dictionaries containing GRCh37 transcript data if successful, otherwise None.
    """
    search_url = f"{TARK_API_URL}transcript/search/"
    params = {
        'identifier_field': hg38_identifier,
        'expand': 'exons,genes'
    }

    data = ApiClient.get_tark_data(search_url, params)
    if not data:
        return None

    hg37_transcripts = [max((item for item in data if item['assembly'] == 'GRCh37'), key=lambda x: int(x['stable_id_version']), default=None)]
    gene_name = next((gene['name'] for item in data for gene in item.get('genes', []) if gene['name']), None)

    if warning:
        for transcript in hg37_transcripts:
            if transcript:
                transcript['warning'] = warning

    return process_transcripts(hg37_transcripts, gene_name or hg38_identifier)

def fetch_coordinate_info(coord: str, assembly: str) -> List[Dict]:
    """
    Obtains gene overlap information for a given genomic coordinate.

    Args:
        coord (str): The genomic coordinate in the format 'chromosome:start-end'.
        assembly (str): The genome assembly version ('GRCh38' or 'GRCh37').

    Returns:
        List[Dict]: A list of dictionaries containing gene overlap information.
    """
    # Validates the coordinate format and raises an error if invalid.
    error = validate_coordinates(coord)
    if error:
        raise ValueError(error)

    # Parses the coordinate string into chromosome, start, and end positions.
    chrom, pos = coord.split(':')
    chrom = chrom.lstrip('chr')
    start, end = map(int, pos.split('-'))

    logger.info(get_ensembl_url(assembly))
    logger.info(f"{chrom} {start} {end}")
    
    # Constructs the URL for the Ensembl API request to get gene overlap information.
    ensembl_url = f"{get_ensembl_url(assembly)}/overlap/region/human/{chrom}:{start}-{end}?feature=gene;content-type=application/json"
    
    # Makes the API request and processes the response.
    data = ApiClient.get_ensembl_data(ensembl_url)
    if not data:
        return [{
            'loc_region': chrom,
            'loc_start': start,
            'loc_end': end,
            'accession': 'N/A',
            'gene': 'N/A',
            'entrez_id': 'N/A',
            'biotype': 'N/A',
            'strand': 'N/A',
        }]

    return process_coordinate_data(data, chrom, start, end, coord)

def process_coordinate_data(data: List[Dict], chrom: str, start: int, end: int, coord: str) -> List[Dict]:
    """
    Processes coordinate data to extract relevant gene overlap information.

    Args:
        data (List[Dict]): A list of feature data dictionaries.
        chrom (str): The chromosome name.
        start (int): The start position of the coordinate.
        end (int): The end position of the coordinate.
        coord (str): The original coordinate string.

    Returns:
        List[Dict]: A list of dictionaries containing processed gene overlap information.
    """
    valid_features = []
    unknown_features = []

    for feature in data:
        feature_entry = {
            'loc_region': chrom,
            'loc_start': start,
            'loc_end': end,
            'accession': feature.get('id', 'unknown_id'),
            'gene': feature.get('external_name', 'unknown_gene'),
            'entrez_id': feature.get('id', 'unknown_id'),
            'biotype': feature.get('biotype', 'unknown_biotype'),
            'strand': feature.get('strand', 1),
            'alert': '',
            'is_genomic_coordinate': True
        }
        
        # Separates known and unknown gene features.
        if feature_entry['gene'] != 'unknown_gene':
            valid_features.append(feature_entry)
        else:
            unknown_features.append(feature_entry)

    # Adds alerts if multiple genes or unknown genes overlap the coordinate.
    if valid_features:
        if len(valid_features) > 1:
            for feature in valid_features:
                feature['alert'] = f"Coordinate {coord} overlaps multiple genes."
        return valid_features
    elif unknown_features:
        if len(unknown_features) > 1:
            for feature in unknown_features:
                feature['alert'] = f"Coordinate {coord} overlaps multiple uncharacterised genomic regions with the VEP API."
        return unknown_features
    else:
        return [{
            'loc_region': chrom,
            'loc_start': start,
            'loc_end': end,
            'accession': 'none',
            'gene': 'none',
            'entrez_id': 'none',
            'biotype': 'none',
            'strand': 'none',
            'alert': f"No genes found overlapping coordinate {coord}."
        }]

def fetch_panels_from_panelapp():
    """
    Fetches panel data from PanelApp API, handling pagination.
    """
    panels_list = []
    next_url = "https://panelapp.genomicsengland.co.uk/api/v1/panels/signedoff/"
    
    while next_url:
        try:
            response = requests.get(next_url)
            response.raise_for_status()
            data = response.json()
            
            panels_list.extend(data['results'])
            next_url = data.get('next')
            
        except requests.RequestException as e:
            current_app.logger.error(f"Error fetching panels from PanelApp: {str(e)}")
            break
    
    return panels_list

def fetch_genes_for_panel(panel_id: int, include_amber: bool, include_red: bool) -> List[Dict]:
    """
    Fetches genes associated with a specific panel from PanelApp.

    Args:
        panel_id (int): The ID of the panel.
        include_amber (bool): Whether to include genes with amber confidence level.
        include_red (bool): Whether to include genes with red confidence level.

    Returns:
        List[Dict]: A list of dictionaries containing gene information.
    """
    url = f"{PANELAPP_API_URL}panels/{panel_id}/"
    
    try:
        response = requests.get(url)
        response.raise_for_status()
        data = response.json()
        
        if not data.get('genes'):
            print(f"No genes found in panel data: {data}")
            return []
        
        genes = []
        for gene in data['genes']:
            confidence = str(gene.get('confidence_level', '0'))
            
            # Only include genes based on confidence level settings
            if (confidence == '3' or 
                (confidence == '2' and include_amber) or 
                (confidence == '1' and include_red)):
                
                genes.append({
                    'symbol': gene.get('gene_data', {}).get('gene_symbol', ''),
                    'confidence': confidence
                })
        
        print(f"Found {len(genes)} genes for panel {panel_id}")
        return genes
        
    except requests.RequestException as e:
        print(f"Error fetching genes from PanelApp: {str(e)}")
        return []
    except Exception as e:
        print(f"Unexpected error fetching genes: {str(e)}")
        return []

def validate_coordinates(coordinates: str) -> Optional[str]:
    """
    Validates the format of genomic coordinates from frontend.

    Args:
        coordinates (str): The genomic coordinates in the format 'chromosome:start-end'.

    Returns:
        Optional[str]: An error message if the format is invalid, otherwise None.
    """
    # Validates the coordinate format using a regular expression.
    regex = r'^(chr)?([1-9][0-9]?|[XYM]):(\d+)-(\d+)$'
    match = re.match(regex, coordinates, re.IGNORECASE)

    if not match:
        return "Invalid format. Use 'chromosome:start-end' (e.g., 1:200-300 or chr1:200-300)."

    start, end = int(match.group(3)), int(match.group(4))

    # Ensures the end position is not less than the start position
    if start > end:
        return "End position cannot be less than start position."

    return None

def get_transcript_data(identifier: str) -> List[Dict]:
    """Gets transcript data from Tark API."""
    # Check if identifier includes a version
    if '.' in identifier and any(identifier.startswith(prefix) for prefix in ['NM_', 'NR_']):
        # Use the direct versioned transcript endpoint
        url = f"{TARK_API_BASE}/transcript/stable_id_with_version/?stable_id_with_version={identifier}"
        response = requests.get(url)
        if response.ok:
            data = response.json()
            # Versioned endpoint returns a single transcript, but keep the list format
            # for consistency with the rest of the code
            return [data] if data else []
    
    # For non-versioned identifiers, use the existing endpoint
    url = f"{TARK_API_BASE}/transcript/stable_id/{identifier}/"
    response = requests.get(url)
    if response.ok:
        return response.json()
    return []
</file>

<file path="app/bed_generator/bed_generator.py">
"""
bed_generator.py - Provides functions to format individual BED lines and create content for different use cases.

Functions:
- format_bed_line: Formats a single BED line based on the specified format type.
- create_bed: Creates BED file content from a list of results in a specified format.
- create_data_bed: Creates BED file content in the 'data' format.
- create_sambamba_bed: Creates BED file content in the 'sambamba' format.
- create_exome_depth_bed: Creates BED file content in the 'exome_depth' format.
- create_cnv_bed: Creates BED file content in the 'cnv' format.
- create_raw_bed: Creates raw BED file content without additional formatting.
"""

from typing import List, Dict, Union
from flask import current_app
import os

class BedGenerator:
    # Define format configurations as a class attribute
    BED_FORMATS = {
        'data': {
            'fields': [
                lambda r, _: str(r['entrez_id']),
                lambda r, _: f"{r['gene']};{r['accession']}"
            ]
        },
        'sambamba': {
            'fields': [
                lambda r, p: f"{r['loc_region']}-{r['loc_start']}-{r['loc_end']}", 
                lambda r, _: "0",
                lambda r, _: '+' if r.get('loc_strand', 1) > 0 else '-',
                lambda r, _: f"{r['gene']};{r['accession']}",
                lambda r, _: str(r['entrez_id'])
            ]
        },
        'exomeDepth': {
            'fields': [
                lambda r, _: f"{r['gene']}_{r.get('exon_number', '')}"
            ]
        },
        'cnv': {
            'fields': [
                lambda r, _: str(r['entrez_id'])
            ]
        }
    }

    @classmethod
    def format_bed_line(cls, result: Dict, padding: int, format_type: str, add_chr_prefix: bool = False) -> str:
        """Formats a single BED line."""
        try:
            # Format chromosome/region
            loc_region = str(result['loc_region'])
            if add_chr_prefix and not loc_region.lower().startswith('chr'):
                loc_region = f'chr{loc_region}'

            # Get coordinates
            start = int(result['loc_start'])
            end = int(result['loc_end'])
            
            # Apply padding if this is not a SNP
            if not result.get('is_snp', False):
                padding_value = int(result.get('_padding', padding))
                if padding_value > 0:
                    start = max(0, start - padding_value)
                    end = end + padding_value
            
            # Format the basic BED fields
            bed_line = f"{loc_region}\t{start}\t{end}"
            
            # Add format-specific fields
            if format_type in cls.BED_FORMATS:
                format_config = cls.BED_FORMATS[format_type]
                additional_fields = []
                for field_func in format_config['fields']:
                    try:
                        field_value = field_func(result, padding)
                        additional_fields.append(str(field_value))
                    except Exception as e:
                        current_app.logger.error(f"Error processing field for format {format_type}: {str(e)}")
                        raise
                
                if additional_fields:
                    bed_line += '\t' + '\t'.join(additional_fields)

            return bed_line
            
        except Exception as e:
            current_app.logger.error(f"Error formatting BED line: {str(e)}")
            current_app.logger.error(f"Result: {result}")
            raise

    @classmethod
    def create_bed(cls, results: List[Dict], padding: int, format_type: str, add_chr_prefix: bool = False) -> str:
        return '\n'.join([cls.format_bed_line(r, padding, format_type, add_chr_prefix) for r in results])

    # Single factory method for generating BED content in any supported format
    @classmethod
    def create_formatted_bed(cls, results: List[Dict], format_type: str, add_chr_prefix: bool = False) -> str:
        """Creates formatted BED file content."""
        print(f"\n=== BedGenerator.create_formatted_bed ===")
        print(f"Format type: {format_type}")
        
        bed_lines = []
        for result in results:
            try:
                print(f"\nInput result:")
                print(f"Gene: {result.get('gene')}")
                print(f"Coordinates: {result.get('loc_start')}-{result.get('loc_end')}")
                print(f"Existing padding: {result.get('_padding')}")
                print(f"UTR info - 5': {result.get('five_prime_utr')}, 3': {result.get('three_prime_utr')}")
                
                # Don't apply additional padding if already present
                padding = 0 if result.get('_padding') is not None else result.get('_padding', 0)
                print(f"Applied padding: {padding}")
                
                bed_line = cls.format_bed_line(
                    result=result,
                    padding=padding,
                    format_type=format_type,
                    add_chr_prefix=add_chr_prefix
                )
                bed_lines.append(bed_line)
            except Exception as e:
                current_app.logger.error(f"Error formatting BED line: {str(e)}")
                continue
        
        return '\n'.join(bed_lines)

    @staticmethod
    def create_raw_bed(results: List[Dict], add_chr_prefix: bool = False) -> str:
        """
        Creates raw BED file content without additional formatting.

        Args:
            results (List[Dict]): A list of dictionaries containing BED entry data.
            add_chr_prefix (bool): Whether to add 'chr' prefix to chromosomes.

        Returns:
            str: The raw BED file content.
        """
        return '\n'.join([f"{'chr' if add_chr_prefix else ''}{r['loc_region']}\t{r['loc_start']}\t{r['loc_end']}\t{r['gene']}" for r in results])

def generate_bed_files(filename: str, results: List[Dict], settings: Dict) -> None:
    """
    Generates different BED file formats based on stored settings in database.
    """
    bed_dir = current_app.config.get('DRAFT_BED_FILES_DIR')
    os.makedirs(bed_dir, exist_ok=True)

    bed_types = {
        'raw': lambda r, p: BedGenerator.create_raw_bed(r, add_chr_prefix=False),
        'data': lambda r, p: BedGenerator.create_formatted_bed(r, 'data', p),
        'sambamba': lambda r, p: BedGenerator.create_formatted_bed(r, 'sambamba', p),
        'exomeDepth': lambda r, p: BedGenerator.create_formatted_bed(r, 'exomeDepth', p),
        'CNV': lambda r, p: BedGenerator.create_formatted_bed(r, 'cnv', p)
    }

    for bed_type, create_function in bed_types.items():
        padding = settings.get('padding', {}).get(bed_type, 0)
        content = create_function(results, padding)
        
        file_path = os.path.join(bed_dir, f"{filename}_{bed_type}.bed")
        with open(file_path, 'w') as f:
            f.write(content)
</file>

<file path="app/bed_generator/database.py">
"""
database.py - Provides functions to store BED files and their entries in the database.

Functions:
- store_bed_file: Stores a BED file and its entries in the database.
- create_bed_file: Creates a new BED file record in the database.
"""

from app import db
from app.models import BedFile, BedEntry
from typing import List, Dict
import json

def store_bed_file(file_name: str, results: List[Dict], user_id: int, initial_query: str, 
                  assembly: str, include_5utr: bool = False, include_3utr: bool = False) -> int:
    """
    Stores a BED file and its entries in the database.
    """
    new_bed_file = BedFile(
        filename=file_name,
        status='draft',
        submitter_id=user_id,
        initial_query=initial_query,
        assembly=assembly,
        include_5utr=include_5utr,
        include_3utr=include_3utr
    )
    db.session.add(new_bed_file)
    db.session.flush()
    
    # Create entries using the model's create_entries method
    BedEntry.create_entries(new_bed_file.id, results)
    
    db.session.commit()
    return new_bed_file.id

def create_bed_file(file_name: str, user_id: int, initial_query: str, assembly: str) -> BedFile:
    # Collect warnings from results
    warnings = []
    initial_query_data = json.loads(initial_query)
    results = initial_query_data.get('results', [])
    
    for result in results:
        if warning := result.get('warning'):
            warnings.append({
                'identifier': result.get('identifier'),
                'message': warning.get('message'),
                'type': warning.get('type')
            })
    
    # Create a summary warning
    file_warning = None
    if warnings:
        file_warning = json.dumps({
            'summary': "Some transcripts require clinical review",
            'details': warnings
        })

    new_bed_file = BedFile(
        filename=file_name,
        status='draft',
        submitter_id=user_id,
        initial_query=initial_query,
        assembly=assembly,
        warning=file_warning
    )
    db.session.add(new_bed_file)
    db.session.flush()
    return new_bed_file
</file>

<file path="app/bed_generator/debug.py">
import logging
import time
from functools import wraps
from typing import Any, Callable
import asyncio

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

# Add a console handler if none exists
if not logger.handlers:
    ch = logging.StreamHandler()
    ch.setLevel(logging.DEBUG)
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    ch.setFormatter(formatter)
    logger.addHandler(ch)

def log_execution_time(func: Callable) -> Callable:
    @wraps(func)
    async def async_wrapper(*args: Any, **kwargs: Any) -> Any:
        start_time = time.time()
        logger.debug(f"Starting {func.__name__} with args: {args}, kwargs: {kwargs}")
        try:
            if asyncio.iscoroutinefunction(func):
                result = await func(*args, **kwargs)
            else:
                result = func(*args, **kwargs)
            execution_time = time.time() - start_time
            logger.debug(f"Finished {func.__name__} in {execution_time:.2f} seconds")
            return result
        except Exception as e:
            logger.error(f"Error in {func.__name__}: {str(e)}")
            raise

    @wraps(func)
    def sync_wrapper(*args: Any, **kwargs: Any) -> Any:
        start_time = time.time()
        logger.debug(f"Starting {func.__name__} with args: {args}, kwargs: {kwargs}")
        try:
            result = func(*args, **kwargs)
            execution_time = time.time() - start_time
            logger.debug(f"Finished {func.__name__} in {execution_time:.2f} seconds")
            return result
        except Exception as e:
            logger.error(f"Error in {func.__name__}: {str(e)}")
            raise

    return async_wrapper if asyncio.iscoroutinefunction(func) else sync_wrapper
</file>

<file path="app/bed_generator/logic.py">
"""
logic.py Core logic for processing genetic data in the bed generator application for processing data.

Functions:
- process_form_data(form): Processes form data to extract and process genetic identifiers and coordinates.
- store_results_in_session(results, no_data_identifiers, assembly, initial_query): Stores processed results in the session.
- process_bulk_data(data): Processes bulk genetic data from a dictionary input.
- get_mane_plus_clinical_identifiers(results): Retrieves identifiers marked as 'MANE PLUS CLINICAL' from results.
- generate_bed_file(bed_type, results, filename_prefix, settings, add_chr_prefix=False): Generates a BED file of a specified type using processed results and settings.
"""

from app import db
from app.models import Settings
from .utils import process_identifiers, process_coordinates
from .bed_generator import BedGenerator
import re
from flask import session
from .api import validate_coordinates
from typing import List, Tuple, Dict, Any, Set
from flask_wtf import FlaskForm
from app.bed_generator.utils import process_tark_data

def process_form_data(form: FlaskForm) -> Tuple[List[Dict[str, Any]], List[str], Dict[str, Any]]:
    """
    Processes form data to extract and process genetic identifiers and coordinates.

    Args:
        form: The form object containing user input data.

    Returns:
        A tuple containing:
        - results: A list of processed genetic data entries.
        - no_data_identifiers: A list of identifiers for which no data was found.
        - initial_query: The initial query made from the frontend.
    """
    results = []
    no_data_identifiers = []
    
    initial_query = {
        'identifiers': form.identifiers.data.split() if form.identifiers.data else [],
        'coordinates': form.coordinates.data.split('\n') if form.coordinates.data else [],
        'assembly': form.assembly.data,
        'include5UTR': form.include5UTR.data,
        'include3UTR': form.include3UTR.data
    }
    
    if form.identifiers.data:
        processed_results, no_data = process_identifiers(
            form.identifiers.data.split(),
            form.assembly.data,
            form.include5UTR.data,
            form.include3UTR.data
        )
        results.extend([r for r in processed_results if isinstance(r, dict)])
        no_data_identifiers.extend(no_data)
    
    if form.coordinates.data:
        processed_coordinates = process_coordinates(form.coordinates.data.split('\n'), form.assembly.data)
        results.extend([r for r in processed_coordinates if isinstance(r, dict)])
    
    return results, no_data_identifiers, initial_query

def store_results_in_session(results: List[Dict[str, Any]], no_data_identifiers: List[str], assembly: str, initial_query: Dict[str, Any]) -> None:
    """
    Stores processed results in the session.

    Args:
        results: A list of processed genetic data entries.
        no_data_identifiers: A list of identifiers for which no data was found.
        assembly: The genome assembly version used for processing.
        initial_query: The initial query made from the frontend.
    """
    session['results'] = results
    session['no_data_identifiers'] = no_data_identifiers
    session['assembly'] = assembly
    session['initial_query'] = initial_query

def process_bulk_data(data: Dict[str, Any]) -> Tuple[List[Dict[str, Any]], List[str]]:
    """
    Processes bulk genetic data from a dictionary input.

    Args:
        data: A dictionary containing identifiers and coordinates to process.

    Returns:
        A tuple containing:
        - results: A list of processed genetic data entries.
        - no_data_identifiers: A list of identifiers for which no data was found.

    Raises:
        ValueError: If any coordinate is invalid.
    """
    results = []
    no_data_identifiers = []
    
    if data.get('identifiers'):
        processed_results, no_data = process_identifiers(
            data['identifiers'],
            data.get('assembly', 'GRCh38'),
            data.get('include5UTR', False),
            data.get('include3UTR', False)
        )
        # Flatten the processed results
        for result in processed_results:
            if isinstance(result, list):
                results.extend(result)
            else:
                results.append(result)
        no_data_identifiers.extend(no_data)
    
    if data.get('coordinates'):
        coordinate_list = [coord.strip() for coord in re.split(r'[,\n]', data['coordinates']) if coord.strip()]
        for coord in coordinate_list:
            error = validate_coordinates(coord)
            if error:
                raise ValueError(error)
        processed_coordinates = process_coordinates(coordinate_list, data.get('assembly', 'GRCh38'))
        # Flatten the processed coordinates
        for coord in processed_coordinates:
            if isinstance(coord, list):
                results.extend(coord)
            else:
                results.append(coord)
    
    # Sort results before returning
    results = sort_results(results)
    return results, no_data_identifiers

def get_mane_plus_clinical_identifiers(results: List[Dict[str, Any]]) -> Set[str]:
    """
    Retrieves identifiers marked as 'MANE PLUS CLINICAL' from results.

    Args:
        results: A list of processed genetic data entries.

    Returns:
        A set of gene identifiers marked as 'MANE PLUS CLINICAL'.
    """
    return set(
        result.get('gene', 'Unknown')
        for result in results
        if isinstance(result, dict) and result.get('mane_transcript_type') == 'MANE PLUS CLINICAL'
    )

def generate_bed_file(bed_type: str, results: List[Dict[str, Any]], filename_prefix: str, settings: Dict[str, Any], add_chr_prefix: bool) -> Tuple[str, str]:
    """
    Generates a BED file of a specified type using processed results and settings.

    Args:
        bed_type: The type of BED file to generate ('raw', 'data', 'sambamba', 'exomeDepth', or 'cnv').
        results: A list of processed genetic data entries.
        filename_prefix: A prefix to use for the generated filename.
        settings: A dictionary containing padding settings for different BED types.
        add_chr_prefix: Whether to add 'chr' prefix to chromosome names.

    Returns:
        A tuple containing:
        - bed_content: The content of the generated BED file as a string.
        - filename: The filename for the generated BED file.

    Raises:
        ValueError: If an invalid BED type is specified.
    """
    if bed_type == 'raw':
        bed_content = BedGenerator.create_raw_bed(results, add_chr_prefix)
        filename = f'{filename_prefix}_raw.bed' if filename_prefix else 'raw.bed'
    else:
        # Map bed_type to settings
        padding_map = {
            'data': settings.get('data_padding', 0),
            'sambamba': settings.get('sambamba_padding', 0),
            'exome_depth': settings.get('exomeDepth_padding', 0),
            'cnv': settings.get('cnv_padding', 0)
        }
        
        # Map bed_type to UTR settings
        utr_settings = {
            'data': (settings.get('data_include_5utr', False), settings.get('data_include_3utr', False)),
            'sambamba': (settings.get('sambamba_include_5utr', False), settings.get('sambamba_include_3utr', False)),
            'exome_depth': (settings.get('exomeDepth_include_5utr', False), settings.get('exomeDepth_include_3utr', False)),
            'cnv': (settings.get('cnv_include_5utr', False), settings.get('cnv_include_3utr', False))
        }
        
        padding = padding_map.get(bed_type.lower(), 0)
        include_5utr, include_3utr = utr_settings.get(bed_type.lower(), (False, False))
        
        # Process results with UTR settings using existing UTR data
        processed_results = []
        for result in results:
            if result.get('is_genomic_coordinate', False):
                processed_results.append(result.copy())
                continue
                
            processed = result.copy()
            if 'full_loc_start' in result and 'full_loc_end' in result:
                # Start with full coordinates
                new_start = result['full_loc_start']
                new_end = result['full_loc_end']

                if result.get('strand', 1) == 1:  # Positive strand
                    if not include_5utr and result.get('five_prime_utr_end'):
                        new_start = max(new_start, int(result['five_prime_utr_end']))
                    if not include_3utr and result.get('three_prime_utr_start'):
                        new_end = min(new_end, int(result['three_prime_utr_start']))
                else:  # Negative strand
                    if not include_5utr and result.get('five_prime_utr_end'):
                        # For negative strand, 5' UTR is at the 3' end
                        new_end = min(new_end, int(result['five_prime_utr_end']))
                    if not include_3utr and result.get('three_prime_utr_start'):
                        # For negative strand, 3' UTR is at the 5' end
                        new_start = max(new_start, int(result['three_prime_utr_start']))
                
                processed['loc_start'] = new_start
                processed['loc_end'] = new_end
                processed['_padding'] = padding
                processed_results.append(processed)
            else:
                processed_results.append(processed)
        
        bed_content = BedGenerator.create_formatted_bed(processed_results, bed_type.lower(), padding, add_chr_prefix)
        filename = f'{filename_prefix}_{bed_type}.bed' if filename_prefix else f'{bed_type}.bed'
    
    return bed_content, filename

def sort_results(results):
    """
    Sorts results by chromosome (numerically and alphabetically) and start position.
    """
    def chromosome_key(chrom):
        # Remove 'chr' prefix if present
        chrom = str(chrom).replace('chr', '').upper()
        # Convert to integer if possible, otherwise keep as string
        try:
            return (0, int(chrom)) if chrom.isdigit() else (1, chrom)
        except ValueError:
            return (1, chrom)

    def sort_key(result):
        # Ensure start position is an integer
        try:
            start = int(result['loc_start'])
        except (ValueError, TypeError):
            start = 0
        return (chromosome_key(result['loc_region']), start)

    return sorted(results, key=sort_key)
</file>

<file path="app/bed_generator/routes.py">
"""
routes.py - Defines the routes for the bed generator app.

Routes:
- index(): Handles the main page for the bed generator, processing form submissions.
- bulk_process(): Processes bulk genetic data submitted via a POST request.
- results(): Displays the results of processed genetic data.
- adjust_padding(): Adjusts padding for results based on user input.
- panels(): Returns the list of panels as a JSON response.
- refresh_panels(): Fetches and updates the panel data from an external source.
- get_genes_by_panel(panel_id): Retrieves genes associated with a specific panel.
- settings(): Displays and updates application settings.
- submit_for_review(): Submits a BED file for review.
- download_bed(bed_type): Generates and returns a specific type of BED file.
- get_published_bed_files(): Retrieves a list of published BED files.
- get_bed_files(): Retrieves a list of all BED files with their details.
- adjust_utrs(): Adjusts UTRs for results based on user input.
- download_raw_bed(): Generates and returns a raw BED file.
- download_custom_bed(bed_type): Generates and returns a custom BED file.
"""

from flask import render_template, request, jsonify, session, current_app, redirect, url_for, flash
from typing import List, Dict, Optional
from flask_login import current_user, login_required
from app.bed_generator import bed_generator_bp
from app.bed_generator.utils import (
    store_panels_in_json, get_panels_from_json, load_settings, collect_warnings, increment_version_number, process_tark_data, fetch_genes_for_panel
)
from app.bed_generator.logic import process_form_data, store_results_in_session, process_bulk_data, get_mane_plus_clinical_identifiers, generate_bed_file
from app.forms import SettingsForm, BedGeneratorForm
from app.bed_generator.bed_generator import generate_bed_files, BedGenerator
from app.models import BedFile, Settings, BedEntry
from app.bed_generator.database import store_bed_file
import traceback
import json
from datetime import datetime 
from app import db
import re
import requests
import os
import concurrent.futures
from typing import List, Dict, Tuple

def fetch_panels_from_panelapp():
    """
    Fetches panel data from PanelApp API, handling pagination.
    Returns a list of panels with their details, ordered by the 'R' code.
    """
    try:
        # PanelApp API base URL for signed-off panels
        base_url = "https://panelapp.genomicsengland.co.uk/api/v1/panels/signedoff/"
        panels = []
        next_url = base_url
        
        while next_url:
            print(f"\nFetching from URL: {next_url}")
            response = requests.get(next_url)
            response.raise_for_status()
            
            data = response.json()
            panels.extend(data.get('results', []))
            next_url = data.get('next')
        
        # Extract relevant panel information
        panel_list = []
        for panel in panels:
            # Extract the 'R' code from relevant_disorders
            relevant_disorders = panel.get('relevant_disorders', [])
            r_code = next((code for code in relevant_disorders if code.startswith('R')), '')
            
            panel_name = panel.get('name', '')
            formatted_name = f"{r_code} - {panel_name}" if r_code else panel_name
            
            print(f"\nOriginal name: {panel_name}")
            print(f"Relevant disorders: {relevant_disorders}")
            print(f"R-code found: {r_code}")
            print(f"Formatted name: {formatted_name}")
            
            panel_list.append({
                'id': panel.get('id'),
                'name': formatted_name,
                'full_name': panel_name,
                'disease_group': panel.get('disease_group', ''),
                'disease_sub_group': panel.get('disease_sub_group', '')
            })
        
        # Sort panels by the 'R' code
        def get_r_number(panel):
            r_match = re.search(r'R(\d+)', panel['name'])
            return int(r_match.group(1)) if r_match else float('inf')
        
        panel_list.sort(key=get_r_number)
        
        print(f"\nFirst 3 sorted panels: {[p['name'] for p in panel_list[:3] if panel_list]}")
        
        return panel_list
        
    except requests.RequestException as e:
        current_app.logger.error(f"Error fetching panels from PanelApp: {str(e)}")
        raise Exception(f"Failed to fetch panels: {str(e)}")
    except Exception as e:
        current_app.logger.error(f"Error processing panels: {str(e)}")
        raise Exception(f"Failed to process panels: {str(e)}")

@bed_generator_bp.route('/', methods=['GET', 'POST'])
def index():
    """
    Renders the main page for the bed generator. Handles form submissions to process genetic data.
    
    GET: Displays the form for data input.
    POST: Processes the submitted form data and redirects to the results page.
    """
    form = BedGeneratorForm()
    panels = get_panels_from_json()
    
    if form.validate_on_submit():
        results, no_data_identifiers, initial_query = process_form_data(form)
        store_results_in_session(results, no_data_identifiers, form.assembly.data, initial_query)
        
        return redirect(url_for('bed_generator.results'))

    return render_template('bed_generator.html', form=form, panels=panels)

@bed_generator_bp.route('/bulk_process', methods=['POST'])
def bulk_process():
    """
    Processes bulk genetic data submitted via a POST request.
    """
    data = request.get_json()
    try:
        results, no_data_identifiers = process_bulk_data(data)
        # Only add original locations if they don't already exist
        for result in results:
            if isinstance(result, dict):
                if 'original_loc_start' not in result:
                    result['original_loc_start'] = result.get('loc_start')
                if 'original_loc_end' not in result:
                    result['original_loc_end'] = result.get('loc_end')
        
        session['results'] = results
        session['assembly'] = data.get('assembly', 'GRCh38')
        session['initial_query'] = data.get('initial_query', {})
        return jsonify({
            'success': True, 
            'message': 'Data processed successfully',
            'no_data_identifiers': no_data_identifiers
        })
    
    except ValueError as e:
        return jsonify({'success': False, 'error': str(e)}), 400
    except Exception as e:
        current_app.logger.error(f"Error in bulk_process: {str(e)}")
        return jsonify({'success': False, 'error': 'An unexpected error occurred.'}), 500

@bed_generator_bp.route('/results')
def results():
    """
    Displays the results of processed genetic data.
    
    Retrieves results from the session and renders them on the results page.
    """
    results = session.get('results', [])
    assembly = session.get('assembly', 'GRCh38')
    initial_query = session.get('initial_query', {})
    no_data_identifiers = session.get('no_data_identifiers', [])
    
    print("Results:", results)
    print("assembly:", assembly)
    print("No data identifiers:", no_data_identifiers)
    
    session['results'] = []
    session['initial_query'] = {}
    session['no_data_identifiers'] = []
    
    mane_plus_clinical_identifiers = get_mane_plus_clinical_identifiers(results)
    has_mane_plus_clinical = bool(mane_plus_clinical_identifiers)
    settings = Settings.get_settings()
    return render_template(
        'results.html',
        results=results,
        assembly=assembly,
        has_mane_plus_clinical=has_mane_plus_clinical,
        mane_plus_clinical_identifiers=list(mane_plus_clinical_identifiers),
        initial_query=json.dumps(initial_query),
        no_data_identifiers=no_data_identifiers,
        settings=settings.to_dict()
    )

@bed_generator_bp.route('/store_no_data', methods=['POST'])
def store_no_data():
    """Store no_data_identifiers in session."""
    data = request.get_json()
    session['no_data_identifiers'] = data.get('no_data_identifiers', [])
    return jsonify({'success': True})

@bed_generator_bp.route('/adjust_padding', methods=['POST'])
def adjust_padding():
    """
    Adjusts the padding for results while preserving UTR settings.
    """
    data = request.get_json()
    padding_5 = int(data.get('padding_5', 0))
    padding_3 = int(data.get('padding_3', 0))
    use_separate_snp_padding = data.get('use_separate_snp_padding', False)
    snp_padding_5 = int(data.get('snp_padding_5', padding_5))
    snp_padding_3 = int(data.get('snp_padding_3', padding_3))
    results = data.get('results', [])
    is_padding_update = data.get('is_padding_update', False)

    adjusted_results = []
    for result in results:
        adjusted = result.copy()
        
        # Skip padding for genomic coordinates
        if result.get('is_genomic_coordinate', False):
            adjusted_results.append(adjusted)
            continue

        # Determine if this is a SNP entry
        is_snp = bool(result.get('rsid')) or result.get('is_snp', False)
        
        # Skip padding if this is a SNP and separate SNP padding is not enabled
        if is_snp and not use_separate_snp_padding:
            adjusted_results.append(adjusted)
            continue

        # Get strand information (default to forward/1 if not specified)
        strand = result.get('strand', 1)
        
        # If this is a padding update, we need to use the original coordinates
        if is_padding_update:
            # Get original coordinates (before any padding)
            original_start = result.get('original_start', result['loc_start'])
            original_end = result.get('original_end', result['loc_end'])
            
            # Store original coordinates if not already stored
            if 'original_start' not in adjusted:
                adjusted['original_start'] = original_start
                adjusted['original_end'] = original_end
            
            # Determine which padding values to use
            if is_snp and use_separate_snp_padding:
                pad_5 = snp_padding_5
                pad_3 = snp_padding_3
            else:
                pad_5 = padding_5
                pad_3 = padding_3

            # Apply padding based on strand direction
            if strand > 0:  # Forward strand
                adjusted['loc_start'] = original_start - pad_5
                adjusted['loc_end'] = original_end + pad_3
            else:  # Reverse strand
                adjusted['loc_start'] = original_start - pad_3
                adjusted['loc_end'] = original_end + pad_5
        
        adjusted_results.append(adjusted)

    return jsonify({
        'success': True,
        'results': adjusted_results
    })

@bed_generator_bp.route('/panels')
def panels():
    """
    Returns the list of panels and last updated timestamp as a JSON response.
    """
    panel_data, last_updated = get_panels_from_json()
    return jsonify({'panels': panel_data, 'last_updated': last_updated})

@bed_generator_bp.route('/refresh_panels')
def refresh_panels():
    """
    Endpoint to refresh panel data from PanelApp.
    """
    try:
        panels = fetch_panels_from_panelapp()
        # Store the panels in the JSON file
        store_panels_in_json(panels)
        
        # Read back the stored data to ensure consistency
        stored_panels, last_updated = get_panels_from_json()
        
        return jsonify({
            'panels': stored_panels,
            'last_updated': last_updated
        })
    except Exception as e:
        current_app.logger.error(f"Error in refresh_panels: {str(e)}")
        return jsonify({
            'error': str(e)
        }), 500

@bed_generator_bp.route('/get_genes_by_panel/<panel_id>')
def get_genes_by_panel(panel_id):
    """
    Retrieves genes associated with a specific panel.
    """
    try:
        # Fetch genes directly from PanelApp API
        genes = fetch_genes_for_panel(int(panel_id), include_amber=True, include_red=True)
        if genes:
            return jsonify({'gene_list': genes})
        else:
            return jsonify({'gene_list': [], 'error': 'No genes found for this panel'})
    except Exception as e:
        print(f"Error fetching genes for panel {panel_id}: {str(e)}")
        return jsonify({'gene_list': [], 'error': f'Error fetching genes: {str(e)}'})


@bed_generator_bp.route('/settings', methods=['GET', 'POST'])
@login_required
def settings():
    """
    Displays and updates application settings.

    GET: Populates the settings form with current settings and renders the settings page.
    POST: Validates and updates the settings based on user input, then redirects to the settings page.

    Returns:
        Renders the settings page with the form.
    """
    form = SettingsForm()
    if form.validate_on_submit():
        Settings.get_settings().update_from_form(form)
        flash('Settings updated successfully', 'success')
        return redirect(url_for('bed_generator.settings'))
    
    Settings.get_settings().populate_form(form)
    return render_template('settings.html', form=form)

@bed_generator_bp.route('/submit_for_review', methods=['POST'])
@login_required
def submit_for_review():
    """
    Submit BED files for review, generating both base and type-specific versions.
    """
    try:
        data = request.get_json()
        file_name = data.get('fileName')
        results = data.get('results', [])
        initial_query = json.loads(data.get('initialQuery'))
        assembly = data.get('assembly')
        settings = Settings.get_settings()

        # Process base BED file if requested
        if data.get('baseOnly', False):
            base_settings = {
                'include_5utr': data.get('include5UTR', False),
                'include_3utr': data.get('include3UTR', False)
            }
            
            # Process entries for base BED file
            processed_results = process_bed_entries(
                results,
                settings=base_settings
            )
            
            # Create base BED file record
            base_query = initial_query.copy()
            base_query['settings'] = base_settings
            
            base_bed_file = BedFile(
                filename=file_name,
                status='draft',
                submitter_id=current_user.id,
                initial_query=json.dumps(base_query),
                assembly=assembly,
                include_5utr=base_settings['include_5utr'],
                include_3utr=base_settings['include_3utr']
            )
            db.session.add(base_bed_file)
            db.session.flush()
            
            # Create entries and generate file
            BedEntry.create_entries(base_bed_file.id, processed_results)
            generate_bed_files(file_name, processed_results, settings.to_dict())
            
        else:
            # Process each BED type
            bed_types = ['data', 'sambamba', 'exomeDepth', 'cnv']
            
            for bed_type in bed_types:
                # Get settings for this bed type
                type_settings = {
                    'include_5utr': getattr(settings, f'{bed_type}_include_5utr', False),
                    'include_3utr': getattr(settings, f'{bed_type}_include_3utr', False)
                }
                
                # Process entries for this type
                processed_results = process_bed_entries(
                    results,
                    settings=type_settings,
                    padding=getattr(settings, f'{bed_type}_padding', 0),
                    snp_padding=getattr(settings, f'{bed_type}_snp_padding', 0)
                )
                
                # Create type-specific query
                type_query = initial_query.copy()
                type_query['settings'] = {
                    **type_settings,
                    'padding': {
                        'standard': getattr(settings, f'{bed_type}_padding', 0),
                        'snp': getattr(settings, f'{bed_type}_snp_padding', 0)
                    },
                    'bed_type': bed_type
                }
                
                # Create BED file record
                type_filename = f"{file_name}_{bed_type}"
                bed_file = BedFile(
                    filename=type_filename,
                    status='draft',
                    submitter_id=current_user.id,
                    initial_query=json.dumps(type_query),
                    assembly=assembly,
                    include_5utr=type_settings['include_5utr'],
                    include_3utr=type_settings['include_3utr']
                )
                db.session.add(bed_file)
                db.session.flush()
                
                # Create entries and generate file
                BedEntry.create_entries(bed_file.id, processed_results)
                generate_bed_files(type_filename, processed_results, settings.to_dict())
        
        db.session.commit()
        return jsonify({'success': True})
        
    except Exception as e:
        current_app.logger.error(f"Error in submit_for_review: {str(e)}")
        current_app.logger.error("Full traceback:", exc_info=True)
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

def generate_bed_files(file_name: str, results: List[Dict], settings: Dict) -> None:
    """
    Generate BED files with the provided results.
    
    Args:
        file_name: Base name for the BED file
        results: List of processed BED entries
        settings: Application settings dictionary
    """
    try:
        # Generate BED content
        bed_content = BedGenerator.create_formatted_bed(
            results=results,
            format_type='raw',  # or specify type based on filename
            add_chr_prefix=False
        )
        
        # Write the file
        draft_dir = current_app.config.get('DRAFT_BED_FILES_DIR')
        os.makedirs(draft_dir, exist_ok=True)
        file_path = os.path.join(draft_dir, f"{file_name}.bed")
        
        with open(file_path, 'w') as f:
            f.write(bed_content)
            
    except Exception as e:
        current_app.logger.error(f"Error generating BED file: {str(e)}")
        current_app.logger.error("Full traceback:", exc_info=True)
        raise

@bed_generator_bp.route('/download_raw_bed', methods=['POST'])
def download_raw_bed():
    try:
        data = request.json
        results = data['results']
        filename_prefix = data.get('filename_prefix', '')
        add_chr_prefix = data.get('add_chr_prefix', False)
        include_5utr = data.get('include_5utr', False)
        include_3utr = data.get('include_3utr', False)
        
        # Process UTR settings from frontend
        adjusted_results = []
        for result in results:
            if not result.get('is_genomic_coordinate', False):
                processed = process_tark_data(result, include_5utr, include_3utr)
                if processed:
                    adjusted_results.append(processed)
            else:
                adjusted_results.append(result)
        
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"{filename_prefix}_{timestamp}_raw.bed" if filename_prefix else f"{timestamp}_raw.bed"
        
        bed_content = BedGenerator.create_formatted_bed(adjusted_results, 'raw', 0, add_chr_prefix)
        
        return jsonify({'content': bed_content, 'filename': filename})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@bed_generator_bp.route('/download_custom_bed/<bed_type>', methods=['POST'])
def download_custom_bed(bed_type):
    try:
        data = request.get_json()
        results = data.get('results', [])
        settings = Settings.get_settings()
        
        # Get settings for this bed type
        db_type = bed_type.lower()
        bed_settings = {
            'include_5utr': getattr(settings, f'{db_type}_include_5utr', False),
            'include_3utr': getattr(settings, f'{db_type}_include_3utr', False)
        }
        
        # Process entries
        processed_results = process_bed_entries(
            results,
            bed_settings,
            padding=getattr(settings, f'{db_type}_padding', 0),
            snp_padding=getattr(settings, f'{db_type}_snp_padding', 0)
        )
        
        # Generate BED file content
        bed_content = BedGenerator.create_formatted_bed(
            results=processed_results,
            format_type=db_type,
            add_chr_prefix=data.get('addChrPrefix', False)
        )
        
        return jsonify({
            'content': bed_content,
            'filename': f"{data.get('filename', 'custom')}_{bed_type}.bed"
        })
    except Exception as e:
        current_app.logger.error(f"Error in download_custom_bed: {str(e)}")
        return jsonify({'error': str(e)}), 500

@bed_generator_bp.route('/get_published_bed_files')
@login_required
def get_published_bed_files():
    try:
        published_files = BedFile.query.filter_by(status='published').all()
        files_data = [{'id': file.id, 'filename': file.filename} for file in published_files]
        return jsonify({'success': True, 'bed_files': files_data})
    except Exception as e:
        current_app.logger.error(f"Error in get_published_bed_files: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500

@bed_generator_bp.route('/get_bed_files')
def get_bed_files():
    try:
        bed_files = BedFile.query.all()
        files_data = [{
            'id': file.id,
            'filename': file.filename,
            'status': file.status,
            'submitter': file.submitter.username if file.submitter else 'Unknown',
            'created_at': file.created_at.strftime('%Y-%m-%d %H:%M:%S'),
            'assembly': file.assembly,
            'include_3utr': file.include_3utr,
            'include_5utr': file.include_5utr
        } for file in bed_files]
        return jsonify({'success': True, 'bed_files': files_data})
    except Exception as e:
        current_app.logger.error(f"Error in get_bed_files: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500

@bed_generator_bp.route('/adjust_utrs', methods=['POST'])
def adjust_utrs():
    try:
        data = request.get_json()
        results = data['results']
        include_5utr = data['include_5utr']
        include_3utr = data['include_3utr']
        
        adjusted_results = []
        for result in results:
            # Skip UTR processing for genomic coordinates
            if (result.get('is_genomic_coordinate', False) or 
                result.get('gene') == 'none' or 
                result.get('alert', '').startswith('No genes found overlapping coordinate')):
                adjusted_results.append(result)
                continue
            
            # Process through process_tark_data for gene-based entries
            processed = process_tark_data(result, include_5utr, include_3utr)
            if processed:
                adjusted_results.append(processed)
        
        return jsonify({
            'success': True,
            'results': adjusted_results
        })
    except Exception as e:
        current_app.logger.error(f"Error in adjust_utrs: {str(e)}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

def get_mane_plus_clinical_identifiers(results):
    """Helper function to identify MANE Plus Clinical transcripts."""
    mane_plus_clinical = set()
    for result in results:
        # Check both the mane_transcript_type field and any potential string variations
        mane_type = result.get('mane_transcript_type', '')
        if isinstance(mane_type, str) and ('PLUS CLINICAL' in mane_type.upper() or 
            'MANE Plus Clinical' in mane_type):
            mane_plus_clinical.add(result.get('gene', ''))
    return mane_plus_clinical

def process_bed_entry(
    entry: Dict,
    settings: Dict[str, bool],
    padding: Optional[int] = None,
    snp_padding: Optional[int] = None
) -> Optional[Dict]:
    """
    Process a single BED entry according to UTR settings and padding requirements.
    Returns None if the entry should be excluded.
    
    Args:
        entry: Dictionary containing the entry data
        settings: Dictionary with 'include_5utr' and 'include_3utr' boolean flags
        padding: Optional padding value for regular entries
        snp_padding: Optional padding value for SNP entries
    """
    # Return genomic coordinates unchanged
    if entry.get('is_genomic_coordinate', False):
        return entry.copy()
    
    result = entry.copy()
    
    # Handle SNPs
    if entry.get('is_snp', False) or entry.get('rsid'):
        if snp_padding:
            center = int(entry['loc_start'])
            result['loc_start'] = center - snp_padding
            result['loc_end'] = center + snp_padding
        return result
    
    strand = entry.get('strand', 1)
    start = int(entry.get('full_loc_start', entry['loc_start']))
    end = int(entry.get('full_loc_end', entry['loc_end']))
    
    # Check if exon is entirely within UTR
    if strand == 1:  # Forward strand
        if not settings['include_5utr'] and entry.get('five_prime_utr_end'):
            utr_end = int(entry['five_prime_utr_end'])
            if end <= utr_end:
                return None
            start = max(start, utr_end)
            
        if not settings['include_3utr'] and entry.get('three_prime_utr_start'):
            utr_start = int(entry['three_prime_utr_start'])
            if start >= utr_start:
                return None
            end = min(end, utr_start)
    else:  # Reverse strand
        if not settings['include_5utr'] and entry.get('five_prime_utr_end'):
            utr_end = int(entry['five_prime_utr_end'])
            if start >= utr_end:
                return None
            end = min(end, utr_end)
            
        if not settings['include_3utr'] and entry.get('three_prime_utr_start'):
            utr_start = int(entry['three_prime_utr_start'])
            if end <= utr_start:
                return None
            start = max(start, utr_start)
    
    # Apply padding if specified
    if padding:
        start = max(0, start - padding)
        end = end + padding
        
    result['loc_start'] = start
    result['loc_end'] = end
    
    return result

def process_bed_entries(
    entries: List[Dict],
    settings: Dict[str, bool],
    padding: Optional[int] = None,
    snp_padding: Optional[int] = None
) -> List[Dict]:
    """
    Process multiple BED entries according to UTR settings and padding requirements.
    
    Args:
        entries: List of dictionaries containing entry data
        settings: Dictionary with 'include_5utr' and 'include_3utr' boolean flags
        padding: Optional padding value for regular entries
        snp_padding: Optional padding value for SNP entries
    """
    processed_entries = []
    
    for entry in entries:
        processed = process_bed_entry(entry, settings, padding, snp_padding)
        if processed:
            processed_entries.append(processed)
            
    return processed_entries
</file>

<file path="app/bed_generator/utils.py">
"""
utils.py - Provides utility functions for processing data.

Functions:
- load_settings: Loads settings from a JSON file.
- process_identifiers: Processes a list of genetic identifiers, fetching data and applying UTR and padding adjustments.
- process_single_identifier: Processes a single genetic identifier, fetching data based on its type.
- process_tark_data: Processes a single TARK data entry, adjusting for UTRs and padding.
- process_coordinates: Processes a list of genomic coordinates, fetching overlapping gene information.
- store_panels_in_json: Stores panel data in a JSON file, formatting the panel names.
- get_panels_from_json: Retrieves panel data from a JSON file.
- store_genes_in_json: Stores gene data for a specific panel in a JSON file.
- get_genes_from_json: Retrieves gene data from a JSON file.
- fetch_and_store_genes_for_panel: Fetches genes for a specific panel and stores them in a JSON file.
"""

import re
import os
import concurrent.futures
import json
from flask import current_app
from app.models import Settings
from typing import List, Dict, Tuple, Any, Optional
from .api import fetch_variant_info, fetch_data_from_tark, fetch_coordinate_info, fetch_genes_for_panel
import datetime

# Constants
PANELS_JSON_PATH = os.path.join(os.path.dirname(__file__), 'panels.json')
GENES_JSON_PATH = os.path.join(os.path.dirname(__file__), 'genes.json')

def load_settings():
    settings = Settings.get_settings()
    return settings.to_dict()

def process_identifiers(identifiers: List[str], assembly: str, include_5utr: bool, include_3utr: bool) -> Tuple[List[Dict[str, Any]], List[str]]:
    """
    Processes a list of genetic identifiers in parallel, fetching data and applying UTR and padding adjustments.
    """
    results = []
    no_data_identifiers = []
    
    print(f"\n=== Starting batch processing of {len(identifiers)} identifiers ===")
    
    # Group identifiers by type for batch processing
    rsids = []
    other_identifiers = []
    for identifier in identifiers:
        if re.match(r'^RS\d+$', identifier, re.IGNORECASE):
            rsids.append(identifier)
        else:
            other_identifiers.append(identifier)
    
    print(f"Found {len(rsids)} rsIDs and {len(other_identifiers)} other identifiers")
    
    with concurrent.futures.ThreadPoolExecutor(max_workers=100) as executor:
        future_to_id = {}
        
        # Submit rsIDs for processing
        for rsid in rsids:
            print(f"Submitting rsID: {rsid}")
            future_to_id[executor.submit(fetch_variant_info, rsid, assembly)] = rsid
        
        # Submit other identifiers for processing
        for identifier in other_identifiers:
            print(f"Submitting identifier: {identifier}")
            future_to_id[executor.submit(fetch_data_from_tark, identifier, assembly)] = identifier
        
        # Process completed futures
        for future in concurrent.futures.as_completed(future_to_id):
            identifier = future_to_id[future]
            try:
                print(f"\n=== Processing results for {identifier} ===")
                data = future.result()
                
                if data:
                    if isinstance(data, list):
                        # Handle MANE SELECT for GRCh37
                        if assembly == 'GRCh37' and not any(d.get('assembly_name') == 'GRCh37' for d in data):
                            mane_select = next((d for d in data if d.get('mane_transcript_type') == 'MANE SELECT'), None)
                            if mane_select and mane_select.get('stable_id'):
                                print(f"Attempting secondary lookup using MANE SELECT stable_id: {mane_select['stable_id']}")
                                secondary_data = fetch_data_from_tark(mane_select['stable_id'], assembly)
                                if secondary_data:
                                    if isinstance(secondary_data, list):
                                        for sd in secondary_data:
                                            sd['mane_transcript_type'] = mane_select.get('mane_transcript_type')
                                            sd['warning'] = {
                                                'type': 'version_specified',
                                                'message': f"Using GRCh37 version of MANE Select transcript"
                                            }
                                    data = secondary_data
                        
                        # Process TARK data
                        for r in data:
                            if r is None:
                                continue
                            processed_r = process_tark_data(r, include_5utr, include_3utr)
                            if processed_r:
                                print(f"Processed: Gene={processed_r.get('gene')}, EntrezID={processed_r.get('entrez_id')}")
                                results.append(processed_r)
                    else:
                        # Handle VariantInfo dataclass
                        variant_dict = {
                            'loc_region': data.loc_region,
                            'loc_start': data.loc_start,
                            'loc_end': data.loc_end,
                            'gene': data.gene,
                            'accession': data.accession,
                            'entrez_id': data.entrez_id,
                            'transcript_biotype': data.rsid,
                            'most_severe_consequence': data.most_severe_consequence,
                            'allele_string': data.allele_string,
                            'original_loc_start': data.loc_start,
                            'original_loc_end': data.loc_end,
                            'rsid': data.rsid,
                            'is_snp': True,
                            'mane_transcript_type': None
                        }
                        print(f"Processed SNP: {variant_dict['rsid']}")
                        results.append(variant_dict)
                else:
                    print(f"No data found for {identifier}")
                    no_data_identifiers.append(identifier)
            except Exception as e:
                print(f"Error processing identifier {identifier}: {e}")
                no_data_identifiers.append(identifier)
    
    print(f"\n=== Batch processing complete ===")
    print(f"Successfully processed: {len(results)} results")
    print(f"Failed to process: {len(no_data_identifiers)} identifiers")
    
    return results, no_data_identifiers

def process_tark_data(r: Dict[str, Any], include_5utr: bool, include_3utr: bool) -> Optional[Dict[str, Any]]:
    if r is None or 'loc_start' not in r or 'loc_end' not in r:
        return None

    strand = r.get('loc_strand', 1)
    
    # Store the full coordinates and UTR positions
    r['full_loc_start'] = r['loc_start']
    r['full_loc_end'] = r['loc_end']
    r['five_prime_utr_end'] = r.get('five_prime_utr', {}).get('end')
    r['three_prime_utr_start'] = r.get('three_prime_utr', {}).get('start')
    r['strand'] = strand

    # Apply initial UTR adjustments
    if strand == 1:  # Positive strand
        if not include_5utr and r['five_prime_utr_end']:
            r['loc_start'] = max(r['loc_start'], r['five_prime_utr_end'])
        if not include_3utr and r['three_prime_utr_start']:
            r['loc_end'] = min(r['loc_end'], r['three_prime_utr_start'])
    else:  # Negative strand
        if not include_5utr and r['five_prime_utr_end']:
            r['loc_end'] = min(r['loc_end'], r['five_prime_utr_end'])
        if not include_3utr and r['three_prime_utr_start']:
            r['loc_start'] = max(r['loc_start'], r['three_prime_utr_start'])
    
    return r

def process_coordinates(coordinates: List[str], assembly: str = 'GRCh38') -> List[Dict[str, Any]]:
    """
    Processes a list of genomic coordinates in parallel, fetching overlapping gene information.
    """
    results = []
    with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
        future_to_coord = {
            executor.submit(fetch_coordinate_info, coord, assembly): coord for coord in coordinates
        }
        for future in concurrent.futures.as_completed(future_to_coord):
            coord = future_to_coord[future]
            try:
                data = future.result()
                if data:
                    # Ensure each result has the is_genomic_coordinate flag set
                    for item in data:
                        item['is_genomic_coordinate'] = True
                    results.extend(data)
            except Exception as e:
                print(f"Error processing coordinate {coord}: {e}")
    
    return results

def store_panels_in_json(panels_data: List[Dict[str, Any]]) -> None:
    """
    Stores panel data in a JSON file, formatting panel names with R-codes.
    """
    try:
        for panel in panels_data:
            panel['id'] = int(panel['id'])
            
            # Get R-code from relevant_disorders
            r_code = next((disorder for disorder in panel.get('relevant_disorders', []) 
                          if disorder.startswith('R')), '')
            
            # Format the full name
            panel['full_name'] = f"{r_code} - {panel['name']}" if r_code else panel['name']
        
        # Use UTC time for consistency
        current_time = datetime.datetime.utcnow().isoformat()
        
        data_to_store = {
            'last_updated': current_time,
            'panels': panels_data
        }
        
        # Ensure the directory exists
        os.makedirs(os.path.dirname(PANELS_JSON_PATH), exist_ok=True)
        
        with open(PANELS_JSON_PATH, 'w') as json_file:
            json.dump(data_to_store, json_file, indent=2)
            
        current_app.logger.info(f"Successfully stored {len(panels_data)} panels to {PANELS_JSON_PATH}")
        
    except Exception as e:
        current_app.logger.error(f"Error storing panels in JSON: {str(e)}")
        raise

def get_panels_from_json() -> Tuple[List[Dict[str, Any]], str]:
    """
    Retrieves panel data and last updated timestamp from a JSON file.
    """
    if not os.path.exists(PANELS_JSON_PATH):
        current_app.logger.warning(f"Panels JSON file not found at {PANELS_JSON_PATH}")
        return [], ''
        
    try:
        with open(PANELS_JSON_PATH, 'r') as json_file:
            data = json.load(json_file)
            
        if isinstance(data, dict):
            return data.get('panels', []), data.get('last_updated', '')
        elif isinstance(data, list):
            current_app.logger.warning("Found old format panels JSON (list instead of dict)")
            return data, ''
        else:
            current_app.logger.error(f"Unexpected data format in panels JSON: {type(data)}")
            return [], ''
            
    except Exception as e:
        current_app.logger.error(f"Error reading panels from JSON: {str(e)}")
        return [], ''
    
def store_genes_in_json(panel_id: int, genes_data: List[Dict[str, Any]]) -> None:
    """
    Stores gene data for a specific panel in a JSON file.

    Args:
        panel_id: The ID of the panel.
        genes_data: A list of dictionaries containing gene information.
    """
    all_genes = get_genes_from_json()
    all_genes[str(panel_id)] = genes_data
    with open(GENES_JSON_PATH, 'w') as json_file:
        json.dump(all_genes, json_file, indent=2)

def get_genes_from_json() -> Dict[str, List[Dict[str, Any]]]:
    """
    Retrieves gene data from a JSON file.

    Returns:
        A dictionary mapping panel IDs to lists of gene information.
    """
    if not os.path.exists(GENES_JSON_PATH):
        return {}
    with open(GENES_JSON_PATH, 'r') as json_file:
        return json.load(json_file)

def fetch_and_store_genes_for_panel(panel_id: int) -> None:
    """
    Fetches genes for a specific panel and stores them in a JSON file.

    Args:
        panel_id: The ID of the panel.
    """
    genes = fetch_genes_for_panel(panel_id, include_amber=True, include_red=True)
    store_genes_in_json(panel_id, genes)

def collect_warnings(results: List[Dict]) -> Optional[str]:
    """
    Collects and formats warnings from results.
    """
    warnings = []
    for result in results:
        if warning := result.get('warning'):
            warnings.append({
                'identifier': result.get('identifier'),
                'message': warning.get('message'),
                'type': warning.get('type')
            })
    
    if warnings:
        return json.dumps({
            'summary': "Some transcripts require clinical review",
            'details': warnings
        })
    return None

def increment_version_number(filename: str) -> str:
    """
    Creates a new version number for an existing BED file.
    """
    match = re.search(r'_v(\d+)$', filename)
    if match:
        current_version = int(match.group(1))
        return re.sub(r'_v\d+$', f'_v{current_version + 1}', filename)
    return f"{filename}_v2"

def standardize_result(result: Dict[str, Any]) -> Dict[str, Any]:
    """
    Standardizes result structure across all entry types.
    """
    standard_result = {
        # Required fields
        'loc_region': result.get('loc_region'),
        'loc_start': result.get('loc_start'),
        'loc_end': result.get('loc_end'),
        'gene': result.get('gene', 'none'),
        
        # Optional fields with defaults
        'entrez_id': result.get('entrez_id', ''),
        'accession': result.get('accession', ''),
        'exon_id': result.get('exon_id', ''),
        'exon_number': result.get('exon_number', ''),
        'transcript_biotype': result.get('transcript_biotype', ''),
        'mane_transcript': result.get('mane_transcript', ''),
        'mane_transcript_type': result.get('mane_transcript_type'),
        
        # Flags
        'is_snp': result.get('is_snp', False),
        'is_genomic_coordinate': result.get('is_genomic_coordinate', False),
        
        # Coordinate tracking
        'original_loc_start': result.get('original_loc_start', result.get('loc_start')),
        'original_loc_end': result.get('original_loc_end', result.get('loc_end')),
        
        # UTR information
        'strand': result.get('strand', 1),
        'five_prime_utr_end': result.get('five_prime_utr_end'),
        'three_prime_utr_start': result.get('three_prime_utr_start'),
        
        # Warning/status information
        'warning': result.get('warning'),
    }
    
    # Store full coordinates if available
    if 'full_loc_start' in result:
        standard_result['full_loc_start'] = result['full_loc_start']
        standard_result['full_loc_end'] = result['full_loc_end']
    
    return standard_result
</file>

<file path="app/bed_manager/__init__.py">
from flask import Blueprint

bed_manager_bp = Blueprint('bed_manager', __name__)

from app.bed_manager import routes
</file>

<file path="app/bed_manager/routes.py">
"""
routes.py - Defines the routes for the bed manager app.

Routes:
- index(): Displays the main page of the bed manager with a list of all bed files.
- submit_bed_file(): Handles the submission of a new BED file.
- review_bed_file(file_id): Manages the review process for a specific BED file.
- remove_bed_file(file_id): Removes a BED file if the user has permission.
- bed_file_details(file_id): Displays details of a specific BED file, including its entries and version history.
- authorise_bed_file(file_id): Authorizes a BED file, publishing it or creating a new version.
- reload_bed_results(file_id): Reloads the results of a BED file into the session for the bed generator.
- compare_bed_files(file_id): Compares a new BED file with its published version or another selected file.
- file_details(file_id): Retrieves and returns detailed information about a specific BED file.
"""

from flask import render_template, request, redirect, url_for, flash, jsonify, session
from flask_login import login_required, current_user
from app.bed_manager import bed_manager_bp
from app.models import BedFile, BedEntry
from app import db
import re
import json

@bed_manager_bp.route('/')
@login_required
def index():
    bed_files = BedFile.query.all()
    return render_template('bed_manager/index.html', bed_files=bed_files)

@bed_manager_bp.route('/remove/<int:file_id>', methods=['POST'])
@login_required
def remove_bed_file(file_id):
    bed_file = BedFile.query.get_or_404(file_id)
    
    # Check if the current user has permission to remove the file
    if current_user.is_authorizer or current_user.id == bed_file.submitter_id:
        try:
            db.session.delete(bed_file)
            db.session.commit()
            return jsonify({'success': True})
        except Exception as e:
            db.session.rollback()
            return jsonify({'success': False, 'error': str(e)})
    else:
        return jsonify({'success': False, 'error': 'You do not have permission to remove this file.'}), 403

@bed_manager_bp.route('/bed_file_details/<int:file_id>')
@login_required
def bed_file_details(file_id):
    bed_file = BedFile.query.options(db.joinedload(BedFile.entries)).get_or_404(file_id)
    published_files = BedFile.query.filter_by(status='published').all()
    
    # Find the previous version of the file
    previous_version = None
    if bed_file.status == 'pending':
        match = re.search(r'_v(\d+)$', bed_file.filename)
        if match:
            current_version = int(match.group(1))
            previous_version_name = re.sub(r'_v\d+$', f'_v{current_version - 1}', bed_file.filename)
            previous_version = BedFile.query.filter_by(filename=previous_version_name, status='published').first()
    
    return render_template('bed_manager/bed_file_details.html', 
                         bed_file=bed_file, 
                         published_files=published_files, 
                         previous_version=previous_version)

@bed_manager_bp.route('/authorise/<int:file_id>', methods=['POST'])
@login_required
def authorise_bed_file(file_id):
    if not current_user.is_authorizer:
        return jsonify({'success': False, 'error': 'You do not have permission to authorise files.'}), 403

    bed_file = BedFile.query.get_or_404(file_id)
    
    if bed_file.status == 'published':
        return jsonify({'success': False, 'error': 'This file is already published.'}), 400

    # Add warning acknowledgment check
    if bed_file.warning and not request.json.get('warningsAcknowledged'):
        return jsonify({
            'success': False, 
            'error': 'You must acknowledge the warnings before authorising this file.'
        }), 400

    try:
        data = request.json
        file_action = data.get('fileAction', 'new')

        if file_action == 'new':
            # Check if the filename already has a version
            if not re.search(r'_v\d+$', bed_file.filename):
                # If not, append _v1 to the filename
                bed_file.filename = f"{bed_file.filename}_v1"
            
            bed_file.status = 'published'
            bed_file.authorizer_id = current_user.id
            message = f'The new BED file "{bed_file.filename}" was successfully published and is now available for analysis.'
        else:
            # Increment version of an existing file
            existing_file = BedFile.query.get(int(file_action))
            if not existing_file:
                return jsonify({'success': False, 'error': 'Selected file for increment not found.'}), 404

            match = re.search(r'_v(\d+)$', existing_file.filename)
            if match:
                current_version = int(match.group(1))
                new_filename = re.sub(r'_v\d+$', f'_v{current_version + 1}', existing_file.filename)
            else:
                new_filename = f"{existing_file.filename}_v2"

            new_file = BedFile(
                filename=new_filename,
                status='published',
                submitter_id=bed_file.submitter_id,
                authorizer_id=current_user.id,
                initial_query=bed_file.initial_query,
                assembly=bed_file.assembly
            )
            db.session.add(new_file)
            db.session.flush()  # This will assign an ID to new_file

            # Copy entries from the pending file to the new file
            for entry in bed_file.entries:
                new_entry = BedEntry(
                    bed_file_id=new_file.id,
                    chromosome=entry.chromosome,
                    start=entry.start,
                    end=entry.end,
                    entrez_id=entry.entrez_id,
                    gene=entry.gene,
                    accession=entry.accession,
                    exon_id=entry.exon_id,
                    exon_number=entry.exon_number,
                    transcript_biotype=entry.transcript_biotype,
                    mane_transcript=entry.mane_transcript,
                    status=entry.status
                )
                db.session.add(new_entry)

            # Set the original pending file to 'draft' status
            bed_file.status = 'draft'

            message = f'A new version of the BED file ({new_filename}) was created and published.'

        db.session.commit()
        return jsonify({'success': True, 'message': message})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)})

@bed_manager_bp.route('/reload_bed_results/<int:file_id>')
@login_required
def reload_bed_results(file_id):
    bed_file = BedFile.query.get_or_404(file_id)
    
    # Store the results in the session
    session['results'] = [
        {
            'loc_region': entry.chromosome,
            'loc_start': entry.start,
            'loc_end': entry.end,
            'entrez_id': entry.entrez_id,
            'gene': entry.gene,
            'accession': entry.accession,
            'exon_id': entry.exon_id,
            'exon_number': entry.exon_number,
            'transcript_biotype': entry.transcript_biotype,
            'mane_transcript': entry.mane_transcript,
            'status': entry.status
        }
        for entry in bed_file.entries
    ]
    session['assembly'] = bed_file.assembly
    
    return jsonify({
        'success': True,
        'redirect_url': url_for('bed_generator.results')
    })

@bed_manager_bp.route('/compare_bed_files/<int:file_id>')
@login_required
def compare_bed_files(file_id):
    new_file = BedFile.query.get_or_404(file_id)
    
    selected_file_id = request.args.get('selected_file_id', 'new')
    
    if selected_file_id != 'new':
        published_file = BedFile.query.get_or_404(int(selected_file_id))
    else:
        # Find the corresponding published file (assuming filenames are versioned)
        base_filename = new_file.filename.rsplit('_v', 1)[0]
        published_file = BedFile.query.filter(
            BedFile.filename.startswith(base_filename),
            BedFile.status == 'published'
        ).order_by(BedFile.created_at.desc()).first()

    new_entries = [
        {
            'chromosome': entry.chromosome,
            'start': entry.start,
            'end': entry.end,
            'gene': entry.gene
        } for entry in new_file.entries
    ]

    if published_file:
        published_entries = [
            {
                'chromosome': entry.chromosome,
                'start': entry.start,
                'end': entry.end,
                'gene': entry.gene
            } for entry in published_file.entries
        ]
        message = None
        published_file_name = published_file.filename
    else:
        published_entries = []
        message = "No published version found for comparison. This may be a new BED file."
        published_file_name = None

    return jsonify({
        'new_file': new_entries,
        'published_file': published_entries,
        'message': message,
        'new_file_name': new_file.filename,
        'published_file_name': published_file_name
    })

@bed_manager_bp.route('/file_details/<int:file_id>')
def file_details(file_id):
    bed_file = BedFile.query.get_or_404(file_id)
    
    # Parse the initial_query JSON string
    try:
        initial_query = json.loads(bed_file.initial_query)
    except json.JSONDecodeError:
        initial_query = {"error": "Invalid JSON"}

    return jsonify({
        'created_at': bed_file.created_at.isoformat(),
        'updated_at': bed_file.updated_at.isoformat(),
        'initial_query': initial_query,
        'warning': json.loads(bed_file.warning) if bed_file.warning else None
    })
</file>

<file path="app/static/js/bed_generator.js">
document.addEventListener('DOMContentLoaded', function() {
    const form = document.getElementById('bedGeneratorForm');
    const generateButton = document.getElementById('generateButton');
    const buttonText = document.getElementById('buttonText');
    const dnaLoader = document.getElementById('dnaLoader');

    loadPanelsFromJSON();

    // Add event listeners
    const eventListeners = {
        'panelDropdown': { event: 'change', handler: updateIdentifiers },
        'includeAmber': { event: 'change', handler: updateIdentifiers },
        'includeRed': { event: 'change', handler: updateIdentifiers },
        'searchPanel': { event: 'keyup', handler: filterPanels },
        'bedFile': { event: 'change', handler: handleBedFileUpload },
        'csvFile': { event: 'change', handler: handleCsvFileUpload }
    };

    Object.entries(eventListeners).forEach(([id, { event, handler }]) => {
        document.getElementById(id).addEventListener(event, handler);
    });

    // Add event listener for form submission
    form.addEventListener('submit', function(event) {
        event.preventDefault();

        var assembly = document.getElementById('assembly').value;
        var identifiersInput = document.getElementById('identifiers').value;
        
        // Check for duplicates in identifiers
        const identifiersList = identifiersInput.split(/[\s,]+/).filter(Boolean);
        const uniqueIdentifiers = [...new Set(identifiersList)];
        
        if (identifiersList.length !== uniqueIdentifiers.length) {
            const duplicates = identifiersList.filter((item, index) => 
                identifiersList.indexOf(item) !== index
            );
            alert(`Please remove duplicate identifiers: ${duplicates.join(', ')}`);
            return;
        }

        // Add this line to capture the initial query
        var initialQuery = {
            identifiers: identifiersInput,
            coordinates: document.getElementById('coordinates').value,
            assembly: assembly,
            include5UTR: false,  // Default to false
            include3UTR: false   // Default to false
        };

        // Modify the payload to include the initial query
        var payload = {
            identifiers: uniqueIdentifiers,  // Use uniqueIdentifiers instead of splitting again
            coordinates: document.getElementById('coordinates').value.trim(),
            assembly: assembly,
            include5UTR: false,
            include3UTR: false,
            initial_query: initialQuery
        };

        // Clear the file inputs before submitting the form
        document.getElementById('bedFile').value = '';
        document.getElementById('csvFile').value = '';

        fetch('/bed_generator/bulk_process', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload)
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Store no_data_identifiers in session
                fetch('/bed_generator/store_no_data', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        no_data_identifiers: data.no_data_identifiers || []
                    })
                }).then(() => {
                    window.location.href = '/bed_generator/results';
                });
            } else {
                alert('Error: ' + data.error);
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('An unexpected error occurred.');
        });
    });
});

// Other functions
function loadPanelsFromJSON() {
    return fetch('/bed_generator/panels')
        .then(response => response.json())
        .then(data => {
            console.log('Loaded panel data:', data); 
            updatePanelDropdown(data);
        })
        .catch(error => console.error('Error loading panels from JSON:', error));
}

function refreshPanels() {
    console.log("Starting panel refresh");
    var refreshButton = document.querySelector('.refresh-button');
    var buttonText = refreshButton.querySelector('.button-text');
    var loadingSpinner = refreshButton.querySelector('.loading-spinner');

    buttonText.style.display = 'none';
    loadingSpinner.style.display = 'inline-block';

    fetch('/bed_generator/refresh_panels')
        .then(response => {
            console.log("Received response:", response);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            console.log("Received data:", data);
            if (data.error) {
                throw new Error(data.error);
            }
            
            // Update the panel dropdown
            updatePanelDropdown(data);
            
            // Update last updated time
            if (data.last_updated) {
                const date = new Date(data.last_updated);
                document.getElementById('lastUpdated').textContent = 
                    'Last updated: ' + date.toLocaleString('en-GB', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    });
            }
        })
        .catch(error => {
            console.error('Error refreshing panels:', error);
            alert('Failed to refresh panels: ' + error.message);
        })
        .finally(() => {
            console.log("Refresh operation completed");
            buttonText.style.display = 'inline';
            loadingSpinner.style.display = 'none';
        });
}

function updatePanelDropdown(data) {
    var select = document.getElementById('panelDropdown');
    select.innerHTML = '<option value="">Select a panel...</option>';
    
    if (Array.isArray(data)) {
        // If data is an array, assume it's the old format (just panels)
        data.forEach(panel => {
            var option = new Option(panel.name, panel.id);
            select.add(option);
        });
    } else if (data && Array.isArray(data.panels)) {
        // If data is an object with a panels array, use the new format
        data.panels.forEach(panel => {
            var option = new Option(panel.name, panel.id);
            select.add(option);
        });
        if (data.last_updated) {
            const date = new Date(data.last_updated);
            document.getElementById('lastUpdated').textContent = 'Last updated: ' + date.toLocaleString();
        }
    } else {
        console.error('Unexpected data format:', data);
        alert('Unexpected data format received from server.');
    }
}

function filterPanels() {
    var input = document.getElementById('searchPanel');
    var filter = input.value.toUpperCase();
    var select = document.getElementById('panelDropdown');
    var options = select.options;

    for (var i = 1; i < options.length; i++) {
        var txtValue = options[i].textContent || options[i].innerText;
        if (txtValue.toUpperCase().indexOf(filter) > -1) {
            options[i].style.display = "";
        } else {
            options[i].style.display = "none";
        }
    }
}

function updateIdentifiers() {
    const panelDropdown = document.getElementById('panelDropdown');
    const selectedOption = panelDropdown.options[panelDropdown.selectedIndex];
    const panelId = selectedOption.value;
    const panelName = selectedOption.text;
    console.log('Selected panel ID:', panelId);
    console.log('Selected panel name:', panelName);
    console.log('Panel dropdown value:', panelDropdown.value);

    const includeAmber = document.getElementById('includeAmber').checked;
    const includeRed = document.getElementById('includeRed').checked;
    const panelLoadingSpinner = document.getElementById('panelLoadingSpinner');

    if (!panelId) {
        console.log('No panel selected, loading panels');
        return loadPanelsFromJSON();
    }

    panelDropdown.disabled = true;
    panelLoadingSpinner.style.display = 'inline-block';

    fetch(`/bed_generator/get_genes_by_panel/${encodeURIComponent(panelId)}`)
        .then(response => response.json())
        .then(data => {
            console.log('Received gene data:', data);
            const geneList = data.gene_list || [];
            console.log('Gene list:', geneList);

            const filteredGenes = geneList.filter(gene => {
                if (includeAmber && gene.confidence === '2') return true;
                if (includeRed && gene.confidence === '1') return true;
                return gene.confidence === '3';
            });

            const geneSymbols = filteredGenes.map(gene => gene.symbol);
            const uniqueGenes = [...new Set(geneSymbols)]; // Remove duplicates
            
            const coloredGenes = uniqueGenes.map(symbol => {
                const gene = filteredGenes.find(g => g.symbol === symbol);
                const colorMap = { '3': 'green', '2': 'orange', '1': 'red' };
                const color = colorMap[gene.confidence] || '';
                return `<span style="color: ${color};">${symbol}</span>`;
            });

            console.log('Filtered and colored genes:', coloredGenes);
            document.getElementById('identifiers').value = uniqueGenes.join(', ');
            console.log('Set identifiers value:', document.getElementById('identifiers').value);
        })
        .catch(error => console.error('Error fetching gene list:', error))
        .finally(() => {
            panelDropdown.disabled = false;
            panelLoadingSpinner.style.display = 'none';
        });
}

function handleBedFileUpload(event) {
    const files = event.target.files;
    let allCoordinates = [];

    for (let file of files) {
        const reader = new FileReader();
        reader.onload = function(e) {
            const contents = e.target.result;
            const lines = contents.split('\n');
            for (let line of lines) {
                const parts = line.trim().split('\t');
                if (parts.length >= 3) {
                    allCoordinates.push(`${parts[0]}:${parts[1]}-${parts[2]}`);
                }
            }
            // Update the coordinates textarea after processing each file
            document.getElementById('coordinates').value = allCoordinates.join('\n');
        };
        reader.readAsText(file);
    }
}

function handleCsvFileUpload(event) {
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
            const contents = e.target.result;
            const identifiers = contents.split(/[\s,]+/).filter(Boolean);
            const uniqueIdentifiers = [...new Set(identifiers)]; // Remove duplicates
            document.getElementById('identifiers').value = uniqueIdentifiers.join(', ');
        };
        reader.readAsText(file);
    }
}

// Log when the script has finished loading
console.log('Script loaded');

document.getElementById('bedGeneratorForm').addEventListener('submit', function(e) {
    var button = document.getElementById('generateButton');
    var spinner = document.getElementById('spinner');
    
    button.style.display = 'none';
    spinner.classList.remove('d-none');
});
</file>

<file path="app/static/js/results.js">
let igvBrowser;
let settings;
let activeRowIndex = 0;
let addChrPrefix = false;
let currentSortColumn = -1;
let sortDirection = 1; // 1 for ascending, -1 for descending
let utrStates = {
    'none': null,
    'both': null,
    '5only': null,
    '3only': null
};
let currentUTRState = 'none';
let igvTracks = [];  // Store track references
let originalResults = null;
let manePlusSelections = new Map();

// Load settings when the page loads
fetch('/bed_generator/settings')
    .then(response => response.json())
    .then(data => {
        settings = data;
        // Set the default assembly in the dropdown
        document.getElementById('genome-select').value = settings.defaultAssembly === 'GRCh38' ? 'hg38' : 'hg19';
    });

document.addEventListener('DOMContentLoaded', function () {
    // Store initial state WITHOUT filtering
    const initialResults = JSON.parse(document.getElementById('bedContent').value);
    console.log('Setting Original Results:', initialResults);
    originalResults = initialResults;
    
    // Check for MANE Plus Clinical transcripts
    if (!handleManePlusTranscripts(initialResults)) {
        // Only update table if no MANE Plus Clinical transcripts found
        updateTable(initialResults);
    }
    
    loadIGV();

    // Add event listener to the file input for uploading BED files
    const uploadButton = document.getElementById('bedFileUpload');
    if (uploadButton) {
        uploadButton.addEventListener('change', handleFileUpload);
    }

    // Add event listener for the new checkbox
    const chrPrefixCheckbox = document.getElementById('addChrPrefix');
    if (chrPrefixCheckbox) {
        chrPrefixCheckbox.addEventListener('change', toggleChrPrefix);
    }

    document.getElementById('separateSnpPadding').addEventListener('change', function() {
        const snpPaddingInputs = document.getElementById('snpPaddingInputs');
        snpPaddingInputs.style.display = this.checked ? 'block' : 'none';
    });

    // Initialize all tooltips
    var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'))
    var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
        return new bootstrap.Tooltip(tooltipTriggerEl)
    });
});

function loadIGV() {
    var igvDiv = document.getElementById('igv-div');
    
    var loadingIndicator = document.createElement('div');
    loadingIndicator.id = 'igv-loading';
    loadingIndicator.innerHTML = 'Loading IGV...';
    igvDiv.appendChild(loadingIndicator);

    var genome = document.getElementById('genome-select').value;

    var results = JSON.parse(document.getElementById('bedContent').value);
    var bedContent = createBedContent(results);

    // Determine the locus to zoom into (e.g., the first region in the BED content)
    var firstRegion = bedContent.split('\n')[0].split('\t');
    var start = Math.max(0, parseInt(firstRegion[1]) - 350); // Zoomed out by 350bp (200 + 150)
    var end = parseInt(firstRegion[2]) + 350; // Zoomed out by 350bp (200 + 150)
    var locus = `${firstRegion[0]}:${start}-${end}`;

    var options = {
        genome: genome,
        locus: locus,  // Zoom into the first region with 350bp padding
        tracks: [
            {
                name: "Custom BED",
                type: "annotation",
                format: "bed",
                color: "rgb(150, 0, 0)",
                features: results.map(result => {
                    return {
                        chr: addChrPrefix && !result.loc_region.startsWith('chr') ? 
                            'chr' + result.loc_region : 
                            result.loc_region,
                        start: parseInt(result.loc_start),
                        end: parseInt(result.loc_end),
                        name: result.gene || '',
                        score: 1000,
                        strand: result.strand === -1 ? '-' : '+'
                    };
                }),
                displayMode: "EXPANDED"
            }
        ]
    };

    igv.createBrowser(igvDiv, options)
        .then(function (browser) {
            console.log('IGV browser created successfully');
            igvBrowser = browser;
            document.getElementById('igv-loading').remove();
            
            // Set the first row as active by default
            const firstRow = document.querySelector('.table tbody tr');
            if (firstRow) {
                setActiveRow(firstRow, 0);
            }
        })
        .catch(function(error) {
            console.error('Error creating IGV browser:', error);
            document.getElementById('igv-loading').innerHTML = 'Error loading IGV. Please try again.';
        });
}

function applyPadding() {
    const padding5 = parseInt(document.getElementById('paddingInput5').value) || 0;
    const padding3 = parseInt(document.getElementById('paddingInput3').value) || 0;
    const useSeparateSnpPadding = document.getElementById('separateSnpPadding').checked;
    const snpPadding5 = useSeparateSnpPadding ? (parseInt(document.getElementById('snpPadding5').value) || 0) : padding5;
    const snpPadding3 = useSeparateSnpPadding ? (parseInt(document.getElementById('snpPadding3').value) || 0) : padding3;
    
    // Get the current state of results (includes UTR changes)
    const bedContentElement = document.getElementById('bedContent');
    const currentResults = JSON.parse(bedContentElement.value);

    fetch('/bed_generator/adjust_padding', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            padding_5: padding5,
            padding_3: padding3,
            use_separate_snp_padding: useSeparateSnpPadding,
            snp_padding_5: snpPadding5,
            snp_padding_3: snpPadding3,
            include_5utr: document.getElementById('include5UTR').checked,
            include_3utr: document.getElementById('include3UTR').checked,
            results: currentResults,  // Use current state instead of original
            is_padding_update: true   // New flag to indicate this is a padding update
        }),
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            updateTable(data.results);
            bedContentElement.value = JSON.stringify(data.results);
            refreshIGV();
        } else {
            console.error('Error applying padding:', data.error);
        }
    })
    .catch(error => {
        console.error('Error:', error);
    });
}


function addFileUploadButton() {
    const igvDiv = document.getElementById('igv-div');
    const uploadButton = document.createElement('input');
    uploadButton.type = 'file';
    uploadButton.id = 'bedFileUpload';
    uploadButton.accept = '.bed';
    uploadButton.style.display = 'none';

    const uploadLabel = document.createElement('label');
    uploadLabel.htmlFor = 'bedFileUpload';
    uploadLabel.className = 'btn btn-primary mt-2';
    uploadLabel.textContent = 'Upload existing BED File for comparison';

    igvDiv.parentNode.insertBefore(uploadLabel, igvDiv.nextSibling);
    igvDiv.parentNode.insertBefore(uploadButton, uploadLabel);

    uploadButton.addEventListener('change', handleFileUpload);
}

function handleFileUpload(event) {
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
            const content = e.target.result;
            addBedTrackToIGV(content, file.name);
            compareBedFiles(content);
        };
        reader.readAsText(file);
    }
}

function addBedTrackToIGV(content, fileName) {
    if (igvBrowser) {
        igvBrowser.loadTrack({
            name: fileName,
            type: "annotation",
            format: "bed",
            color: "yellow",
            features: content.split('\n').map(line => {
                const parts = line.split('\t');
                return {
                    chr: parts[0],
                    start: parseInt(parts[1]),
                    end: parseInt(parts[2]),
                    name: parts[3] || ''
                };
            }),
            displayMode: "EXPANDED"
        }).then(function() {
            console.log('New BED track added successfully');
        }).catch(function(error) {
            console.error('Error adding new BED track:', error);
            alert('Error adding new BED track. Please try again.');
        });
    }
}

function changeGenome() {
    var genome = document.getElementById('genome-select').value;
    if (igvBrowser) {
        igvBrowser.loadGenome(genome);
    }
}

function createBedContent(results) {
    return results.map(r => {
        const chrValue = r.loc_region;
        const chrPrefix = addChrPrefix && !chrValue.toLowerCase().startsWith('chr') ? 'chr' : '';
        return `${chrPrefix}${r.loc_region}\t${r.loc_start}\t${r.loc_end}\t${r.gene}`;
    }).join('\n');
}

function updateFilenamePrefixForAll() {
    var prefix = document.getElementById('bedFileNamePrefix').value.trim();
    if (prefix) {
        localStorage.setItem('bedFileNamePrefix', prefix);
    } else {
        localStorage.removeItem('bedFileNamePrefix');
    }
}

function downloadRawBed() {
    const results = JSON.parse(document.getElementById('bedContent').value);
    const addChrPrefix = document.getElementById('addChrPrefix').checked;
    
    // Create bed content directly from table data
    const bedContent = results.map(r => {
        // Only add chr prefix if it's not already there
        const chrValue = r.loc_region;
        const chrPrefix = addChrPrefix && !chrValue.toLowerCase().startsWith('chr') ? 'chr' : '';
        return `${chrPrefix}${r.loc_region}\t${r.loc_start}\t${r.loc_end}\t${r.gene}`;
    }).join('\n');
    
    // Create filename with timestamp
    const timestamp = new Date().toISOString().slice(0,19).replace(/[-:]/g, '').replace('T', '_');
    const filename = `raw_bed_${timestamp}.bed`;
        
    // Download file
    const blob = new Blob([bedContent], { type: 'text/plain' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    window.URL.revokeObjectURL(url);
    document.body.removeChild(a);
}

function downloadCustomBed(bedType) {
    // Debug logs
    console.log('Original Results:', originalResults);
    console.log('Current Results:', JSON.parse(document.getElementById('bedContent').value));
    
    if (!originalResults) {
        console.error('Original results not found');
        alert('Debug: Original results are missing!');
        return;
    }

    // Use a default filename format: type_YYYYMMDD.bed
    const today = new Date();
    const dateStr = today.toISOString().slice(0,10).replace(/-/g, '');
    const filename = `${bedType}_${dateStr}`; // Default filename format
    
    // Additional debug log before sending request
    console.log('Sending to server:', {
        results: originalResults,
        filename: filename,
        addChrPrefix: addChrPrefix
    });

    fetch('/bed_generator/download_custom_bed/' + bedType, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            results: originalResults,
            filename: filename,
            addChrPrefix: addChrPrefix
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            throw new Error(data.error);
        }
        downloadFile(data.content, data.filename);
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error generating BED file: ' + error.message);
    });
}

function downloadFile(content, filename) {
    const blob = new Blob([content], { type: 'text/plain' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    window.URL.revokeObjectURL(url);
    document.body.removeChild(a);
}

function downloadBedFile(bedType, data) {
    fetch(`/bed_generator/download_bed/${bedType}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(data)
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            alert('Error: ' + data.error);
        } else {
            const blob = new Blob([data.content], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = data.filename;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('An unexpected error occurred.');
    });
}

function downloadBEDSet() {
    const results = JSON.parse(document.getElementById('bedContent').value);
    fetch('/bed_generator/download_bed_set', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ results: results }),
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        if (data.error) {
            throw new Error(data.error);
        }
        Object.entries(data).forEach(([filename, content]) => {
            const blob = new Blob([content], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        });
    })
    .catch(error => {
        console.error('Error:', error);
        alert('An error occurred while downloading the BED set: ' + error.message);
    });
}

function showSubmitModal() {
    var submitModal = new bootstrap.Modal(document.getElementById('submitModal'));
    submitModal.show();
}

function getInitialQueryAndPadding() {
    const padding5 = parseInt(document.getElementById('paddingInput5').value) || 0;
    const padding3 = parseInt(document.getElementById('paddingInput3').value) || 0;
    const useSeparateSnpPadding = document.getElementById('separateSnpPadding').checked;
    const snpPadding5 = useSeparateSnpPadding ? (parseInt(document.getElementById('snpPadding5').value) || 0) : padding5;
    const snpPadding3 = useSeparateSnpPadding ? (parseInt(document.getElementById('snpPadding3').value) || 0) : padding3;

    let updatedInitialQuery = { ...initialQuery };
    updatedInitialQuery.padding_5 = padding5;
    updatedInitialQuery.padding_3 = padding3;
    updatedInitialQuery.use_separate_snp_padding = useSeparateSnpPadding;
    updatedInitialQuery.snp_padding_5 = snpPadding5;
    updatedInitialQuery.snp_padding_3 = snpPadding3;

    return {
        initialQuery: updatedInitialQuery,
        padding_5: padding5,
        padding_3: padding3,
        snp_padding_5: snpPadding5,
        snp_padding_3: snpPadding3,
        use_separate_snp_padding: useSeparateSnpPadding
    };
}

function submitForReview() {
    if (!originalResults) {
        console.error('Original results not found');
        alert('Error: Original results are missing!');
        return;
    }

    const fileName = document.getElementById('bedFileName').value.trim();
    const assembly = document.getElementById('genome-select').value;
    const include5UTR = document.getElementById('include5UTR').checked;
    const include3UTR = document.getElementById('include3UTR').checked;
    const baseOnly = document.getElementById('baseOnly').checked;

    const { initialQuery } = getInitialQueryAndPadding();
    initialQuery.include5UTR = include5UTR;
    initialQuery.include3UTR = include3UTR;

    fetch('/bed_generator/submit_for_review', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ 
            results: originalResults,
            fileName: fileName,
            initialQuery: JSON.stringify(initialQuery),
            assembly: assembly,
            include5UTR: include5UTR,
            include3UTR: include3UTR,
            baseOnly: baseOnly
        }),
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            alert('BED file submitted for review successfully!');
            window.location.href = '/bed_manager';
        } else {
            alert('Error submitting BED file: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error submitting BED file');
    });
}

function adjustValue(button, adjustment, index, field) {
    const input = button.parentElement.querySelector('input');
    const currentValue = parseInt(input.value, 10);
    const newValue = currentValue + adjustment;
    input.value = newValue;
    updateResult(input, index, field);
    refreshIGV();
}

function setActiveRow(row, index) {
    // Remove active class from all rows
    document.querySelectorAll('.table tbody tr').forEach(tr => tr.classList.remove('active-row'));
    
    // Add active class to clicked row
    row.classList.add('active-row');
    
    // Update active row index
    activeRowIndex = index;
    
    // Update IGV viewer
    updateIGVLocus();
}

function updateIGVLocus() {
    if (igvBrowser) {
        const results = JSON.parse(document.getElementById('bedContent').value);
        const activeResult = results[activeRowIndex];
        const start = Math.max(0, parseInt(activeResult.loc_start) - 150);
        const end = parseInt(activeResult.loc_end) + 150;
        const locus = `${activeResult.loc_region}:${start}-${end}`;
        igvBrowser.search(locus);
    }
}

function compareBedFiles(uploadedContent) {
    const generatedResults = JSON.parse(document.getElementById('bedContent').value);
    // Filter out comment lines (starting with #) and empty lines
    const uploadedResults = uploadedContent.split('\n')
        .filter(line => line.trim() && !line.trim().startsWith('#'))
        .map(line => {
            const parts = line.split('\t');
            return {
                chr: normalizeChromosome(parts[0]),
                start: parseInt(parts[1]),
                end: parseInt(parts[2])
            };
        });

    const uniqueInGenerated = [];
    const uniqueInUploaded = [];

    generatedResults.forEach(generated => {
        const normalizedGeneratedChr = normalizeChromosome(generated.loc_region);
        const overlap = uploadedResults.some(uploaded => 
            uploaded.chr === normalizedGeneratedChr &&
            uploaded.start <= generated.loc_end &&
            uploaded.end >= generated.loc_start
        );

        if (!overlap) {
            uniqueInGenerated.push(`${generated.loc_region}:${generated.loc_start}-${generated.loc_end}`);
        }
    });

    uploadedResults.forEach(uploaded => {
        const overlap = generatedResults.some(generated => 
            normalizeChromosome(generated.loc_region) === uploaded.chr &&
            uploaded.start <= generated.loc_end &&
            uploaded.end >= generated.loc_start
        );

        if (!overlap) {
            uniqueInUploaded.push(`${uploaded.chr}:${uploaded.start}-${uploaded.end}`);
        }
    });

    const comparisonResultElement = document.getElementById('comparisonResult');
    if (uniqueInGenerated.length > 0 || uniqueInUploaded.length > 0) {
        comparisonResultElement.innerHTML = '';
        const uniqueRegionsLink = document.createElement('a');
        uniqueRegionsLink.href = '#';
        uniqueRegionsLink.style.color = 'red';
        uniqueRegionsLink.textContent = 'Unique regions detected';
        uniqueRegionsLink.addEventListener('click', function(event) {
            event.preventDefault();
            showUniqueRegionsModal();
        });
        comparisonResultElement.appendChild(uniqueRegionsLink);
        populateUniqueRegionsPane(uniqueInGenerated, uniqueInUploaded);
    } else {
        comparisonResultElement.textContent = 'All regions overlap.';
        comparisonResultElement.style.color = 'green';
        document.getElementById('uniqueRegionsPane').style.display = 'none';
    }
}

function showUniqueRegionsModal() {
    const uniqueRegionsModal = new bootstrap.Modal(document.getElementById('uniqueRegionsModal'));
    uniqueRegionsModal.show();
}

function populateUniqueRegionsPane(uniqueInGenerated, uniqueInUploaded) {
    const uniqueRegionsList = document.getElementById('uniqueRegionsList');
    
    if (!uniqueRegionsList) {
        console.error('Required elements not found');
        return;
    }

    uniqueRegionsList.innerHTML = '';

    const addRegionToList = (region, source) => {
        const listItem = document.createElement('li');
        listItem.className = 'list-group-item';
        listItem.textContent = `${source}: ${region}`;
        listItem.style.cursor = 'pointer';
        listItem.addEventListener('click', function() {
            showRegionInIGV(region);
            const uniqueRegionsModal = bootstrap.Modal.getInstance(document.getElementById('uniqueRegionsModal'));
            uniqueRegionsModal.hide();
        });
        uniqueRegionsList.appendChild(listItem);
    };

    if (uniqueInGenerated.length > 0) {
        uniqueInGenerated.forEach(region => addRegionToList(region, 'Generated BED'));
    }

    if (uniqueInUploaded.length > 0) {
        uniqueInUploaded.forEach(region => addRegionToList(region, 'Uploaded BED'));
    }
}

function showRegionInIGV(region) {
    if (igvBrowser) {
        const [chr, range] = region.split(':');
        const [start, end] = range.split('-').map(Number);
        const locus = `${chr}:${start}-${end}`;
        igvBrowser.search(locus);
    }
}

function normalizeChromosome(chr) {
    // Remove 'chr' prefix if present and convert to uppercase for consistency
    return chr.replace(/^chr/i, '').toUpperCase();
}

function toggleChrPrefix() {
    addChrPrefix = document.getElementById('addChrPrefix').checked;
    
    // Get the current results and update them
    const results = JSON.parse(document.getElementById('bedContent').value);
    results.forEach(result => {
        const chrValue = result.loc_region;
        if (addChrPrefix && !chrValue.startsWith('chr')) {
            result.loc_region = 'chr' + chrValue;
        } else if (!addChrPrefix && chrValue.startsWith('chr')) {
            result.loc_region = chrValue.substring(3);
        }
    });
    
    // Update the hidden input with modified results
    document.getElementById('bedContent').value = JSON.stringify(results);
    
    // Update just the table
    updateTable(results);
}

function handleBedFileUpload(event) {
    const files = event.target.files;
    let allCoordinates = [];

    const processFile = (file) => {
        return new Promise((resolve) => {
            const reader = new FileReader();
            reader.onload = function(e) {
                const contents = e.target.result;
                const lines = contents.split('\n');
                let coordinates = [];
                for (let line of lines) {
                    const parts = line.trim().split('\t');
                    if (parts.length >= 3) {
                        // Check if the file name ends with "_CNV.bed"
                        if (file.name.endsWith('_CNV.bed')) {
                            coordinates.push(`${parts[0]}:${parts[1]}-${parts[2]}`);
                        } else {
                            // For other BED files, include the gene name if available
                            const geneName = parts.length > 3 ? parts[3] : '';
                            coordinates.push(`${parts[0]}:${parts[1]}-${parts[2]}${geneName ? ' ' + geneName : ''}`);
                        }
                    }
                }
                resolve(coordinates);
            };
            reader.readAsText(file);
        });
    };

    Promise.all(Array.from(files).map(processFile))
        .then(results => {
            allCoordinates = results.flat();
            document.getElementById('coordinates').value = allCoordinates.join('\n');
        });
}

// Combine updateTable and refreshTable into a single function
function updateTable(results) {
    const tableBody = document.querySelector('.table tbody');
    tableBody.innerHTML = '';

    const validResults = results.filter(result => 
        parseInt(result.loc_start) <= parseInt(result.loc_end)
    );

    validResults.forEach((result, index) => {
        const row = document.createElement('tr');
        row.onclick = function() { setActiveRow(this, index); };
        
        // Format status display
        let statusDisplay = '';
        if (result.is_snp) {
            statusDisplay = '<span class="badge bg-info text-white"><i class="fas fa-dna"></i> SNP</span>';
        } else if (result.status) {
            // Apply appropriate styling based on status type
            const statusClass = result.status.includes('MANE') ? 'bg-success' : 'bg-info';
            statusDisplay = `<span class="badge ${statusClass} text-white">${result.status}</span>`;
        }
        
        row.innerHTML = `
            <td>${result.loc_region}</td>
            <td>${result.loc_start}</td>
            <td>${result.loc_end}</td>
            <td>${result.entrez_id}</td>
            <td style="background-color: #d4edda;">${result.gene}</td>
            <td>${result.accession}</td>
            <td>${result.exon_id}</td>
            <td>${result.exon_number}</td>
            <td>${result.transcript_biotype}</td>
            <td>${result.mane_transcript}</td>
            <td>${statusDisplay}</td>
        `;
        
        tableBody.appendChild(row);
    });

    document.getElementById('bedContent').value = JSON.stringify(validResults);
    currentResults = validResults;
}

function updateIGV(results) {
    if (!igvBrowser) return;

    // Create bed features from results
    const bedFeatures = results.map(result => ({
        chr: addChrPrefix && !result.loc_region.startsWith('chr') ? 
            'chr' + result.loc_region : 
            result.loc_region,
        start: parseInt(result.loc_start),
        end: parseInt(result.loc_end),
        name: result.gene || 'Unknown',
        score: 1000,
        strand: result.strand === -1 ? '-' : '+'
    }));

    // Find existing custom track
    const existingTrack = igvBrowser.trackViews.find(trackView => 
        trackView.track.name === 'Custom BED'
    )?.track;

    if (existingTrack) {
        // Update existing track
        existingTrack.features = bedFeatures;
        igvBrowser.updateViews();
    } else {
        // Create new track if none exists
        const bedTrack = {
            name: 'Custom BED',
            type: 'annotation',
            format: 'bed',
            features: bedFeatures,
            displayMode: 'EXPANDED',
            color: 'rgb(150, 0, 0)'
        };
        igvBrowser.loadTrack(bedTrack);
    }
}

function toggleUTR() {
    const include5 = document.getElementById('include5UTR').checked;
    const include3 = document.getElementById('include3UTR').checked;
    
    if (!originalResults) {
        console.error('Original results not found');
        return;
    }

    // Get current padding values
    const padding5 = parseInt(document.getElementById('paddingInput5').value) || 0;
    const padding3 = parseInt(document.getElementById('paddingInput3').value) || 0;
    const useSeparateSnpPadding = document.getElementById('separateSnpPadding').checked;
    const snpPadding5 = useSeparateSnpPadding ? (parseInt(document.getElementById('snpPadding5').value) || 0) : padding5;
    const snpPadding3 = useSeparateSnpPadding ? (parseInt(document.getElementById('snpPadding3').value) || 0) : padding3;

    // Process each result
    const adjustedResults = originalResults.map(result => {
        // Skip if it's a genomic coordinate
        if (result.is_genomic_coordinate) {
            return result;
        }

        let newStart = result.full_loc_start || result.loc_start;
        let newEnd = result.full_loc_end || result.loc_end;

        // Apply UTR adjustments
        if (result.strand === 1) {  // Positive strand
            if (!include5 && result.five_prime_utr_end) {
                newStart = Math.max(newStart, result.five_prime_utr_end);
            }
            if (!include3 && result.three_prime_utr_start) {
                newEnd = Math.min(newEnd, result.three_prime_utr_start);
            }
        } else {  // Negative strand
            if (!include5 && result.five_prime_utr_end) {
                newEnd = Math.min(newEnd, result.five_prime_utr_end);
            }
            if (!include3 && result.three_prime_utr_start) {
                newStart = Math.max(newStart, result.three_prime_utr_start);
            }
        }

        // Determine if this is a SNP entry
        const is_snp = result.rsid || result.is_snp;

        // Skip padding for SNPs unless separate SNP padding is enabled
        if (is_snp && !useSeparateSnpPadding) {
            return {
                ...result,
                loc_start: newStart,
                loc_end: newEnd
            };
        }

        // Apply appropriate padding
        if (is_snp && useSeparateSnpPadding) {
            newStart -= snpPadding5;
            newEnd += snpPadding3;
        } else if (!is_snp) {
            newStart -= padding5;
            newEnd += padding3;
        }
        
        return {
            ...result,
            loc_start: newStart,
            loc_end: newEnd
        };
    });

    // Update table and other UI elements
    updateTable(adjustedResults);
    document.getElementById('bedContent').value = JSON.stringify(adjustedResults);
    refreshIGV();
}

function downloadFile(content, filename) {
    const blob = new Blob([content], { type: 'text/plain' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    window.URL.revokeObjectURL(url);
    document.body.removeChild(a);
}

function handleManePlusTranscripts(results) {
    console.log("Starting handleManePlusTranscripts with:", results);
    
    // Group results by gene and transcript type
    const geneTranscripts = new Map();
    
    for (const result of results) {
        if (!result.gene || !result.status) continue;
        
        if (!geneTranscripts.has(result.gene)) {
            geneTranscripts.set(result.gene, new Set());
        }
        geneTranscripts.get(result.gene).add(result.status);
    }
    
    console.log("Grouped gene transcripts:", Array.from(geneTranscripts.entries()));
    
    // Find genes that have both MANE Select and MANE Plus Clinical
    const genesWithBothTypes = new Map();
    
    for (const [gene, statuses] of geneTranscripts.entries()) {
        console.log(`Checking ${gene} with statuses:`, Array.from(statuses));
        if (statuses.has('MANE Select transcript') && statuses.has('MANE Plus Clinical transcript')) {
            console.log(`${gene} has both transcript types`);
            // Group all results for this gene
            genesWithBothTypes.set(gene, results.filter(r => r.gene === gene));
        }
    }
    
    console.log("Genes with both types:", Array.from(genesWithBothTypes.entries()));
    
    if (genesWithBothTypes.size > 0) {
        console.log("Showing transcript selection modal");
        showTranscriptSelectionModal(genesWithBothTypes);
        return true;
    }
    
    console.log("No genes with both transcript types found");
    return false;
}

function showTranscriptSelectionModal(geneTranscripts) {
    console.log("Setting up modal with transcripts:", geneTranscripts);
    const optionsContainer = document.getElementById('transcriptOptions');
    optionsContainer.innerHTML = '';

    geneTranscripts.forEach((transcripts, gene) => {
        const maneSelect = transcripts.find(t => t.status === 'MANE Select transcript');
        const manePlus = transcripts.find(t => t.status === 'MANE Plus Clinical transcript');
        
        console.log(`Creating options for ${gene}:`, { maneSelect, manePlus });
        
        const geneDiv = document.createElement('div');
        geneDiv.className = 'mb-3';
        geneDiv.innerHTML = `
            <h6 class="mb-2">${gene}</h6>
            <div class="form-check">
                <input class="form-check-input" type="radio" name="transcript_${gene}" 
                       value="mane_select" id="mane_select_${gene}" checked>
                <label class="form-check-label" for="mane_select_${gene}">
                    MANE Select (${maneSelect?.accession || 'N/A'})
                </label>
            </div>
            <div class="form-check">
                <input class="form-check-input" type="radio" name="transcript_${gene}" 
                       value="mane_plus" id="mane_plus_${gene}">
                <label class="form-check-label" for="mane_plus_${gene}">
                    MANE Plus Clinical (${manePlus?.accession || 'N/A'})
                </label>
            </div>
        `;
        optionsContainer.appendChild(geneDiv);
    });

    const modal = document.getElementById('maneSelectionModal');
    console.log("Modal element:", modal);
    if (!modal) {
        console.error("Modal element not found!");
        return;
    }
    
    const bootstrapModal = new bootstrap.Modal(modal);
    console.log("Showing modal");
    bootstrapModal.show();
}

function applyTranscriptSelection() {
    console.log("Applying transcript selection");
    const results = JSON.parse(document.getElementById('bedContent').value);
    const updatedResults = [];
    
    // Get all genes that had selections
    const selections = new Map();
    document.querySelectorAll('[id^="mane_select_"]').forEach(radio => {
        const gene = radio.id.replace('mane_select_', '');
        const selectedType = document.querySelector(`input[name="transcript_${gene}"]:checked`).value;
        selections.set(gene, selectedType === 'mane_select' ? 'MANE Select transcript' : 'MANE Plus Clinical transcript');
    });
    
    console.log("Selected transcript types:", Array.from(selections.entries()));

    // Filter results based on selections
    results.forEach(result => {
        if (!result.gene || !selections.has(result.gene)) {
            // Keep results for genes that didn't have selections
            updatedResults.push(result);
        } else if (result.status === selections.get(result.gene)) {
            // Keep only the selected transcript type for genes that had selections
            updatedResults.push(result);
        }
        // Drop results for unselected transcript types
    });
    
    console.log("Updated results:", updatedResults);

    // Update both the current results and originalResults
    document.getElementById('bedContent').value = JSON.stringify(updatedResults);
    originalResults = updatedResults;
    
    // Update the table with new results
    updateTable(updatedResults);
    
    // Refresh IGV
    refreshIGV();
    
    // Hide the modal
    const modal = bootstrap.Modal.getInstance(document.getElementById('maneSelectionModal'));
    modal.hide();
}

function showBedFlowDiagram() {
    const modalHtml = `
        <div class="modal fade" id="bedFlowModal" tabindex="-1">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header bg-light">
                        <h5 class="modal-title">
                            <i class="fas fa-project-diagram me-2"></i>BED File Generation Flow
                        </h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                    </div>
                    <div class="modal-body">
                        <div class="text-center mb-4">
                            <img src="/static/images/bed_flow_diagram.png" alt="BED File Flow Diagram" class="img-fluid rounded shadow-sm">
                        </div>
                        
                        <div class="card">
                            <div class="card-header bg-light">
                                <h6 class="mb-0">
                                    <i class="fas fa-info-circle me-2"></i>How it works
                                </h6>
                            </div>
                            <div class="card-body">
                                <div class="timeline">
                                    <div class="timeline-item mb-3 d-flex">
                                        <div class="timeline-marker me-3">
                                            <span class="badge rounded-pill bg-primary">1</span>
                                        </div>
                                        <div class="timeline-content">
                                            <p class="mb-0">A base BED file is generated from your user input query</p>
                                        </div>
                                    </div>
                                    
                                    <div class="timeline-item mb-3 d-flex">
                                        <div class="timeline-marker me-3">
                                            <span class="badge rounded-pill bg-primary">2</span>
                                        </div>
                                        <div class="timeline-content">
                                            <p class="mb-0">The Base BED download can be modified, and uses your current screen adjustments</p>
                                        </div>
                                    </div>
                                    
                                    <div class="timeline-item mb-3 d-flex">
                                        <div class="timeline-marker me-3">
                                            <span class="badge rounded-pill bg-primary">3</span>
                                        </div>
                                        <div class="timeline-content">
                                            <p class="mb-0">Custom BED profiles use separate settings configured in Settings. These profiles are not affected by padding adjustments made in this screen.</p>
                                        </div>
                                    </div>
                                    
                                    <div class="timeline-item d-flex">
                                        <div class="timeline-marker me-3">
                                            <span class="badge rounded-pill bg-primary">4</span>
                                        </div>
                                        <div class="timeline-content">
                                            <p class="mb-0">Therefore, when submitting BED files for review, only the Base BED file is required. This is stored and used to generate secondary BED profiles as needed.</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer bg-light">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                    </div>
                </div>
            </div>
        </div>

        <style>
            .timeline-marker {
                min-width: 40px;
                text-align: center;
            }
            
            .timeline-item {
                position: relative;
            }
            
            .timeline-item:not(:last-child):before {
                content: '';
                position: absolute;
                left: 19px;
                top: 30px;
                height: calc(100% + 15px);
                width: 2px;
                background-color: #e9ecef;
            }
            
            .modal-lg {
                max-width: 800px;
            }
            
            .badge.rounded-pill {
                width: 25px;
                height: 25px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
        </style>`;
    
    // Add modal to document if it doesn't exist
    if (!document.getElementById('bedFlowModal')) {
        document.body.insertAdjacentHTML('beforeend', modalHtml);
    }
    
    // Show the modal
    const modal = new bootstrap.Modal(document.getElementById('bedFlowModal'));
    modal.show();
}

// Add this function to store the original results when they're first loaded
function storeOriginalResults(results) {
    // Store as a data attribute on the bedContent element
    document.getElementById('bedContent').setAttribute('data-original-results', JSON.stringify(results));
}

function updateResults(results) {
    // Store the original results first
    storeOriginalResults(results);
    
    // Update the table and other UI elements as before
    updateTable(results);
    document.getElementById('bedContent').value = JSON.stringify(results);
    refreshIGV();
}

function checkForManePlusTranscripts(results) {
    const manePlusGenes = new Map();
    console.log("Checking for MANE Plus transcripts:", results);

    // First pass: Group transcripts by gene
    for (const result of results) {
        if (result.gene && result.status) {  // Changed from mane_transcript_type to status
            console.log(`Found transcript for ${result.gene}:`, result.status);
            if (!manePlusGenes.has(result.gene)) {
                manePlusGenes.set(result.gene, []);
            }
            manePlusGenes.get(result.gene).push(result);
        }
    }

    console.log("Grouped transcripts:", Array.from(manePlusGenes.entries()));

    // Second pass: Filter to only keep genes that have both transcript types
    for (const [gene, transcripts] of manePlusGenes.entries()) {
        const hasManePlus = transcripts.some(t => t.status === 'MANE Plus Clinical');  // Changed from mane_transcript_type
        const hasManeSelect = transcripts.some(t => t.status === 'MANE Select');  // Changed from mane_transcript_type
        
        console.log(`${gene} - Has MANE Plus: ${hasManePlus}, Has MANE Select: ${hasManeSelect}`);
        
        if (!hasManePlus || !hasManeSelect) {
            manePlusGenes.delete(gene);
        }
    }

    console.log("Filtered genes with both types:", Array.from(manePlusGenes.entries()));

    if (manePlusGenes.size > 0) {
        showTranscriptSelectionModal(manePlusGenes);
        return true;
    }
    return false;
}

function refreshIGV() {
    if (!igvBrowser) return;
    
    const results = JSON.parse(document.getElementById('bedContent').value);
    
    // Remove existing Custom BED track
    const tracks = igvBrowser.trackViews.map(tv => tv.track);
    const customTrackIndex = tracks.findIndex(track => track.name === 'Custom BED');
    if (customTrackIndex !== -1) {
        igvBrowser.removeTrack(tracks[customTrackIndex]);
    }
    
    // Add new track with updated data
    const bedTrack = {
        name: 'Custom BED',
        type: 'annotation',
        format: 'bed',
        features: results.map(result => ({
            chr: addChrPrefix && !result.loc_region.startsWith('chr') ? 
                'chr' + result.loc_region : 
                result.loc_region,
            start: parseInt(result.loc_start),
            end: parseInt(result.loc_end),
            name: result.gene || 'Unknown',
            score: 1000,
            strand: result.strand === -1 ? '-' : '+'
        })),
        displayMode: 'EXPANDED',
        color: 'rgb(150, 0, 0)'
    };
    
    igvBrowser.loadTrack(bedTrack);
}
</file>

<file path="app/templates/auth/login.html">
{% extends 'base.html' %}

{% block title %}Login{% endblock %}

{% block content %}
            <!-- Page Title Card -->
        <div class="card shadow-sm mb-4" style="background-color: #f8f9fa; margin-top: 20px;">
            <div class="card-body text-center" style="background-color: #fafafa;">
                <h4 class="my-1 page-title">Login</h4>
            </div>
        </div>

        <form method="POST">
            <div class="mb-3">
                <label for="username" class="form-label">Username</label>
                <input type="text" class="form-control" id="username" name="username" required>
            </div>
            <div class="mb-3">
                <label for="password" class="form-label">Password</label>
                <input type="password" class="form-control" id="password" name="password" required>
            </div>
            <button type="submit" class="btn btn-primary">Login</button>
        </form>
        {% with messages = get_flashed_messages(with_categories=true) %}
            {% if messages %}
                <div class="mt-3">
                    {% for category, message in messages %}
                        <div class="alert alert-{{ category }} alert-dismissible fade show" role="alert">
                            {{ message }}
                            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                        </div>
                    {% endfor %}
                </div>
            {% endif %}
        {% endwith %}
{% endblock %}
</file>

<file path="app/templates/auth/user_management.html">
{% extends 'base.html' %}

{% block title %}User Management{% endblock %}

{% block content %}
    <!-- Page Title Card -->
    <div class="card shadow-sm mb-4" style="background-color: #f8f9fa; margin-top: 20px;">
        <div class="card-body text-center" style="background-color: #fafafa;">
            <h4 class="my-1 page-title">User Management</h4>
        </div>
    </div>

    <div class="card shadow-sm mb-4" style="background-color: #f8f9fa;">
        <div class="card-body">
            <h4 class="mt-2 mb-3">Create New User</h4>
            <form action="{{ url_for('auth.create_user') }}" method="POST" class="mb-4"><hr>
                <div class="mb-3">
                    <label for="username" class="form-label">Username</label>
                    <input type="text" class="form-control" id="username" name="username" required>
                </div>
                <div class="mb-3">
                    <label for="email" class="form-label">Email</label>
                    <input type="email" class="form-control" id="email" name="email" required>
                </div>
                <div class="mb-3">
                    <label for="password" class="form-label">Password</label>
                    <input type="password" class="form-control" id="password" name="password" required>
                </div>
                <div class="mb-3">
                    <label for="job_role" class="form-label">Job Role</label>
                    <select class="form-control" id="job_role" name="job_role" required>
                        <option value="">Select a job role</option>
                        <option value="Bioinformatics">Bioinformatics</option>
                        <option value="Cancer Team">Cancer Team</option>
                        <option value="Rare Disease Team">Rare Disease Team</option>
                    </select>
                </div>
                <div class="mb-3 form-check">
                    <input type="checkbox" class="form-check-input" id="is_authorizer" name="is_authorizer">
                    <label class="form-check-label" for="is_authorizer">Make this user an authoriser</label>
                </div>
                <button type="submit" class="btn btn-primary">Create User</button>
            </form>
        </div>
    </div>

    <div class="card shadow-sm mb-4" style="background-color: #f8f9fa;">
        <div class="card-body">
            <h4 class="mt-2 mb-3">Existing Users</h4><hr>
            <table class="table">
                <thead>
                    <tr>
                        <th>Username</th>
                        <th>Email</th>
                        <th>Job Role</th>
                        <th>Authoriser?</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody>
                    {% for user in users %}
                        <tr>
                            <td>{{ user.username }}</td>
                            <td>{{ user.email }}</td>
                            <td>{{ user.role }}</td>
                            <td>{{ 'Yes' if user.is_authorizer else 'No' }}</td>
                            <td>
                                <form action="{{ url_for('auth.set_authorizer', user_id=user.id) }}" method="POST" class="d-inline">
                                    <input type="hidden" name="is_authorizer" value="{{ 'false' if user.is_authorizer else 'true' }}">
                                    <button type="submit" class="btn btn-sm {{ 'btn-danger' if user.is_authorizer else 'btn-success' }}">
                                        {{ 'Remove Authorizer' if user.is_authorizer else 'Make Authorizer' }}
                                    </button>
                                </form>
                            </td>
                        </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
    </div>
{% endblock %}
</file>

<file path="app/templates/bed_manager/bed_file_details.html">
<h5>{{ bed_file.filename }}</h5>


<div class="table-responsive">
    <table class="table table-bordered table-striped">
        <thead>
            <tr>
                <th>Chromosome</th>
                <th>Start</th>
                <th>End</th>
                <th>EntrezID</th>
                <th>Gene</th>
                <th>Accession</th>
                <th>Exon ID</th>
                <th>Exon Number</th>
                <th>Transcript Biotype</th>
                <th>Ensembl Transcript ID</th>
                <th>Status</th>
            </tr>
        </thead>
        <tbody>
            {% for entry in bed_file.entries %}
            <tr>
                <td>{{ entry.chromosome }}</td>
                <td>{{ entry.start }}</td>
                <td>{{ entry.end }}</td>
                <td>{{ entry.entrez_id }}</td>
                <td>{{ entry.gene }}</td>
                <td>{{ entry.accession }}</td>
                <td>{{ entry.exon_id }}</td>
                <td>{{ entry.exon_number }}</td>
                <td>{{ entry.transcript_biotype }}</td>
                <td>{{ entry.mane_transcript }}</td>
                <td>{{ entry.status }}</td>
            </tr>
            {% endfor %}
        </tbody>
    </table>
</div>

<!-- Move warning acknowledgment to bottom of table -->
{% if bed_file.warning %}
    <div class="alert alert-warning mt-3" id="reviewWarningSection">
        <div class="form-check">
            <input class="form-check-input" type="checkbox" id="warningAcknowledged">
            <label class="form-check-label" for="warningAcknowledged">
                I have reviewed all warnings and confirm this file is ready for authorisation
            </label>
        </div>
    </div>
{% endif %}

<div class="mt-3">
    <h5>File Action:</h5>
    <select class="form-select" id="fileAction" name="fileAction" onchange="showComparison()">
        <option value="new">Create new file</option>
        {% for file in published_files %}
            <option value="{{ file.id }}">Increment version: {{ file.filename }}</option>
        {% endfor %}
    </select>
</div>

<!-- Update this section for the comparison view -->
<div id="comparisonView" class="mt-4" style="display: none;">
    <h5>Comparison View</h5>
    <div class="row">
        <div class="col-md-6">
            <h6 id="existingFileHeader"></h6>
            <div id="existingFileContent" class="border p-2" style="max-height: 300px; overflow-y: auto;"></div>
        </div>
        <div class="col-md-6">
            <h6 id="newFileHeader"></h6>
            <div id="newFileContent" class="border p-2" style="max-height: 300px; overflow-y: auto;"></div>
        </div>
    </div>
</div>
</file>

<file path="app/templates/bed_manager/index.html">
{% extends 'base.html' %}

{% block title %}BED Manager{% endblock %}

{% block content %}
    <!-- Page Title Card -->
    <div class="card shadow-sm mb-4" style="background-color: #f8f9fa;">
        <div class="card-body text-center" style="background-color: #fafafa;">
            <h4 class="my-1 page-title">Manage BED Files</h4>
        </div>
    </div>
    
    <!-- Draft BED files card -->
    <div class="card shadow-sm mb-4">
        <div class="card-header" style="background-color: #f8f9fa;">
            <i class="bi bi-file-earmark-text" style="padding-right: 5px;"></i>Pending BED Files
        </div>
        <div class="table-container">
            <table class="table table-bordered table-striped mb-0">
                <thead>
                    <tr>
                        <th>ID</th>
                        <th>File Name</th>
                        <th>Submitter</th>
                        <th>5' UTR</th>
                        <th>3' UTR</th>
                        <th>Status</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody>
                    {% for bed_file in bed_files if bed_file.status != 'published' %}
                        <tr>
                            <td>{{ bed_file.id }}</td>
                            <td>{{ bed_file.filename }}</td>
                            <td>{{ bed_file.submitter.username }}</td>
                            <td class="text-center">
                                {% if bed_file.include_5utr %}
                                    <i class="bi bi-check-circle-fill text-success" title="5' UTR included"></i>
                                {% else %}
                                    <i class="bi bi-x-circle-fill text-muted" title="5' UTR not included"></i>
                                {% endif %}
                            </td>
                            <td class="text-center">
                                {% if bed_file.include_3utr %}
                                    <i class="bi bi-check-circle-fill text-success" title="3' UTR included"></i>
                                {% else %}
                                    <i class="bi bi-x-circle-fill text-muted" title="3' UTR not included"></i>
                                {% endif %}
                            </td>
                            <td>
                                <span class="badge rounded-pill bg-{{ bed_file.status|lower }}">
                                    {{ bed_file.status }}
                                </span>
                            </td>
                            <td>
                                {% if current_user.is_authorizer %}
                                    <button class="btn btn-primary btn-sm review-bed-file" data-file-id="{{ bed_file.id }}">Review</button>
                                    <button class="btn btn-danger btn-sm remove-bed-file" data-file-id="{{ bed_file.id }}">Delete entry</button>
                                {% endif %}
                                <button class="btn btn-info btn-sm view-details" data-file-id="{{ bed_file.id }}">View original query</button>
                            </td>
                        </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
    </div>

    <!-- Published BED files card -->
    <div class="card shadow-sm mb-4">
        <div class="card-header" style="background-color: #b9fbd8;">
            <i class="bi bi-check-circle" style="padding-right: 5px;"></i>Live BED Files
        </div>
        <div class="table-container">
            <table class="table table-bordered table-striped mb-0">
                <thead>
                    <tr>
                        <th>ID</th>
                        <th>File Name</th>
                        <th>Submitter</th>
                        <th>Authoriser</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody>
                    {% for bed_file in bed_files if bed_file.status == 'published' %}
                        <tr>
                            <td>{{ bed_file.id }}</td>
                            <td>{{ bed_file.filename }}</td>
                            <td>{{ bed_file.submitter.username }}</td>
                            <td>{{ bed_file.authorizer.username }}</td>
                            <td>
                                <button class="btn btn-success btn-sm open-in-results" data-file-id="{{ bed_file.id }}">Open in Results editor</button>
                                {% if current_user.is_authorizer %}                                        
                                    <button class="btn btn-danger btn-sm remove-bed-file" data-file-id="{{ bed_file.id }}">Delete entry</button>
                                {% endif %}
                                <button class="btn btn-info btn-sm view-details" data-file-id="{{ bed_file.id }}">View original query</button>
                            </td>
                        </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
    </div>

    <!-- Modal for BED file details -->
    <div class="modal fade" id="bedFileModal">
        <div class="modal-dialog" style="max-width: 70vw;">
            <div class="modal-content">
                <div class="modal-header" style="background: linear-gradient(45deg, #f8f9fa, #ffffff);">
                    <h5 class="modal-title" style="color: #004a99; font-weight: 600; letter-spacing: 0.5px;">
                        <i class="bi bi-file-text" style="padding-right: 5px;"></i>Original Query Details
                    </h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body" id="bedFileModalBody" style="background-color: #fafafa;">
                    <!-- Content will be loaded here -->
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-primary" data-bs-dismiss="modal" data-file-id="">Authorise and publish BED</button>
                    <button type="button" class="btn btn-success" onclick="reloadBedResults(this.getAttribute('data-file-id'))">Open in Results editor</button>
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Original query details modal -->
    <div class="modal fade" id="detailsModal" tabindex="-1" aria-labelledby="detailsModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="detailsModalLabel">BED File Details</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="query-workflow" id="queryWorkflow">
                        <!-- Content will be populated by JavaScript -->
                    </div>
                </div>
                <div class="modal-footer justify-content-start">
                    <button class="btn btn-primary" onclick="reQueryData(this.getAttribute('data-query'))">
                        <i class="bi bi-arrow-repeat"></i> Re-run Query
                    </button>
                    <button class="btn btn-outline-secondary" onclick="showRawQuery(this.getAttribute('data-query'))">
                        <i class="bi bi-code-slash"></i> View Raw Query
                    </button>
                    <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>
{% endblock %}

{% block scripts %}
    {{ super() }}
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            var bedFileModal = new bootstrap.Modal(document.getElementById('bedFileModal'));
            
            // Review button click handler
            document.querySelectorAll('.review-bed-file').forEach(function(button) {
                button.addEventListener('click', function(e) {
                    e.preventDefault();
                    var fileId = this.getAttribute('data-file-id');
                    fetch('/bed_manager/bed_file_details/' + fileId)
                    .then(response => response.text())
                    .then(html => {
                        document.getElementById('bedFileModalBody').innerHTML = html;
                        document.querySelector('#bedFileModal .btn-primary').setAttribute('data-file-id', fileId);
                        document.querySelector('#bedFileModal .btn-success').setAttribute('data-file-id', fileId);
                        
                        // Add the fileAction event listener only after the modal content is loaded
                        const fileActionSelect = document.getElementById('fileAction');
                        if (fileActionSelect) {
                            fileActionSelect.addEventListener('change', showComparison);
                        }
                        
                        bedFileModal.show();
                    });
                });
            });

            document.querySelectorAll('.remove-bed-file').forEach(function(button) {
                button.addEventListener('click', function(e) {
                    e.preventDefault();
                    if (confirm('Are you sure you want to remove this BED file?')) {
                        var fileId = this.getAttribute('data-file-id');
                        fetch('/bed_manager/remove/' + fileId, { method: 'POST' })
                            .then(response => response.json())
                            .then(data => {
                                if (data.success) {
                                    this.closest('tr').remove();
                                } else {
                                    alert('Failed to remove BED file: ' + data.error);
                                }
                            })
                            .catch(error => {
                                console.error('Error:', error);
                                alert('An error occurred while removing the BED file.');
                            });
                    }
                });
            });

            // Add event listener for "Open in Results editor" buttons in the Live BED table
            document.querySelectorAll('.open-in-results').forEach(function(button) {
                button.addEventListener('click', function(e) {
                    e.preventDefault();
                    var fileId = this.getAttribute('data-file-id');
                    reloadBedResults(fileId);
                });
            });

            // Update the "Authorise and publish BED" button click handler
            document.querySelector('#bedFileModal .btn-primary').addEventListener('click', function() {
                // Add warning acknowledgment check
                if (document.getElementById('warningAcknowledged')) {
                    if (!document.getElementById('warningAcknowledged').checked) {
                        alert('Please acknowledge the warnings before authorising this file.');
                        return;
                    }
                }

                var fileId = this.getAttribute('data-file-id');
                var fileAction = document.getElementById('fileAction').value;
                
                fetch(`/bed_manager/authorise/${fileId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        fileAction: fileAction,
                        warningsAcknowledged: true
                    }),
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Create and show the alert
                        var alert = document.createElement('div');
                        alert.className = 'alert alert-success alert-dismissible fade show';
                        alert.role = 'alert';
                        alert.innerHTML = `
                            <strong>Success!</strong> ${data.message}
                            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                        `;
                        document.querySelector('.container').insertBefore(alert, document.querySelector('.container').firstChild);

                        // Reload the page after a short delay
                        setTimeout(() => {
                            location.reload();
                        }, 3000);
                    } else {
                        alert('Failed to authorise and publish BED file: ' + data.error);
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('An error occurred while authorising the BED file.');
                });
            });

            function reloadBedResults(fileId) {
                fetch(`/bed_manager/reload_bed_results/${fileId}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            // Store any warnings in localStorage before redirecting
                            const warningSection = document.getElementById('warningSection');
                            if (warningSection && warningSection.style.display !== 'none') {
                                const warningContent = document.getElementById('warningContent').innerHTML;
                                localStorage.setItem('bedWarnings', warningContent);
                            } else {
                                localStorage.removeItem('bedWarnings');
                            }
                            window.location.href = data.redirect_url;
                        } else {
                            alert('Failed to reload BED results: ' + data.error);
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        alert('An error occurred while reloading the BED results.');
                    });
            }

            function showComparison() {
                var fileAction = document.getElementById('fileAction');
                var comparisonView = document.getElementById('comparisonView');
                var publishedFileContent = document.getElementById('existingFileContent');
                var newFileContent = document.getElementById('newFileContent');
                var existingFileHeader = document.getElementById('existingFileHeader');
                var newFileHeader = document.getElementById('newFileHeader');

                var fileId = document.querySelector('#bedFileModal .btn-primary').getAttribute('data-file-id');
                var selectedFileId = fileAction.value;
                
                fetch(`/bed_manager/compare_bed_files/${fileId}?selected_file_id=${selectedFileId}`)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Network response was not ok');
                        }
                        return response.json();
                    })
                    .then(data => {
                        newFileContent.innerHTML = formatBedContent(data.new_file);
                        publishedFileContent.innerHTML = data.message ? 
                            `<p>${data.message}</p>` : 
                            formatBedContent(data.published_file);
                        comparisonView.style.display = 'block';
                        
                        // Update headers with file names
                        newFileHeader.textContent = data.new_file_name || 'New Version';
                        existingFileHeader.textContent = data.published_file_name || 'Published Version';
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        alert('An error occurred while comparing BED files: ' + error.message);
                        comparisonView.style.display = 'none';
                    });
            }

            function formatBedContent(content) {
                if (!Array.isArray(content)) {
                    console.error('Expected an array, but got:', content);
                    return 'Error: Invalid data format';
                }
                return content.map(entry => 
                    `${entry.chromosome}\t${entry.start}\t${entry.end}\t${entry.gene}`
                ).join('<br>');
            }
        });

            // Use event delegation for "View Details" buttons
            document.body.addEventListener('click', function(e) {
                if (e.target && e.target.classList.contains('view-details')) {
                    e.preventDefault();
                    var fileId = e.target.getAttribute('data-file-id');

                    fetch('/bed_manager/file_details/' + fileId)
                        .then(response => response.json())
                        .then(data => {
                            console.log('Received data:', data);
                            
                            // Format the workflow visualization
                            const initialQuery = typeof data.initial_query === 'string' ? 
                                JSON.parse(data.initial_query) : data.initial_query;
                            
                            // Get submitter from the table row
                            const row = e.target.closest('tr');
                            const submitterCell = row.querySelector('td:nth-child(3)');
                            const submitter = submitterCell ? submitterCell.textContent.trim() : 'Not available';
                            
                            // Format dates
                            const formatDate = (dateStr) => {
                                if (!dateStr) return 'Not available';
                                const date = new Date(dateStr);
                                return date.toLocaleString('en-GB', {
                                    day: '2-digit',
                                    month: '2-digit',
                                    year: 'numeric',
                                    hour: '2-digit',
                                    minute: '2-digit'
                                });
                            };
                            
                            // Combine file metadata with query data
                            const combinedData = {
                                ...initialQuery,
                                created_date: formatDate(data.created_at),
                                updated_date: formatDate(data.updated_at),
                                submitter: submitter
                            };
                            
                            document.getElementById('queryWorkflow').innerHTML = 
                                formatQueryWorkflow(combinedData);
                            
                            var detailsModal = new bootstrap.Modal(document.getElementById('detailsModal'));
                            detailsModal.show();
                        })
                        .catch(error => {
                            console.error('Error:', error);
                            alert('An error occurred while fetching file details.');
                        });
                }
            });

        function reloadBedResults(fileId) {
            fetch(`/bed_manager/reload_bed_results/${fileId}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        window.location.href = data.redirect_url;
                    } else {
                        alert('Failed to reload BED results: ' + data.error);
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('An error occurred while reloading the BED results.');
                });
        }

        function showComparison() {
            var fileAction = document.getElementById('fileAction');
            var comparisonView = document.getElementById('comparisonView');
            var publishedFileContent = document.getElementById('existingFileContent');
            var newFileContent = document.getElementById('newFileContent');
            var existingFileHeader = document.getElementById('existingFileHeader');
            var newFileHeader = document.getElementById('newFileHeader');

            var fileId = document.querySelector('#bedFileModal .btn-primary').getAttribute('data-file-id');
            var selectedFileId = fileAction.value;
            
            fetch(`/bed_manager/compare_bed_files/${fileId}?selected_file_id=${selectedFileId}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    newFileContent.innerHTML = formatBedContent(data.new_file);
                    publishedFileContent.innerHTML = data.message ? 
                        `<p>${data.message}</p>` : 
                        formatBedContent(data.published_file);
                    comparisonView.style.display = 'block';
                    
                    // Update headers with file names
                    newFileHeader.textContent = data.new_file_name || 'New Version';
                    existingFileHeader.textContent = data.published_file_name || 'Published Version';
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('An error occurred while comparing BED files: ' + error.message);
                    comparisonView.style.display = 'none';
                });
        }

        function formatBedContent(content) {
            if (!Array.isArray(content)) {
                console.error('Expected an array, but got:', content);
                return 'Error: Invalid data format';
            }
            return content.map(entry => 
                `${entry.chromosome}\t${entry.start}\t${entry.end}\t${entry.gene}`
            ).join('<br>');
        }

        function formatQueryWorkflow(queryData) {
            // Store the query data on the buttons
            document.querySelector('#detailsModal .modal-footer .btn-primary')
                .setAttribute('data-query', JSON.stringify(queryData));
            document.querySelector('#detailsModal .modal-footer .btn-outline-secondary')
                .setAttribute('data-query', JSON.stringify(queryData));
            
            // Define workflow steps with corrected padding access
            const workflowSteps = [
                {
                    icon: 'bi-info-circle',
                    title: 'File Information',
                    content: `
                        <div class="parameter-tag">
                            <span class="param-label">Created:</span>
                            <span class="param-value">${queryData.created_date || 'Not available'}</span>
                        </div>
                        <div class="parameter-tag">
                            <span class="param-label">Last Updated:</span>
                            <span class="param-value">${queryData.updated_date || 'Not available'}</span>
                        </div>
                        <div class="parameter-tag">
                            <span class="param-label">Created By:</span>
                            <span class="param-value">${queryData.submitter || 'Not available'}</span>
                        </div>
                    `
                },
                {
                    icon: 'bi-diagram-3-fill',
                    title: 'Assembly Selection',
                    content: `
                        <div class="parameter-tag">
                            <span class="param-label">Assembly:</span>
                            <span class="param-value">${queryData.assembly || 'Not available'}</span>
                        </div>
                    `
                },
                {
                    icon: 'bi-input-cursor-text',
                    title: 'Input Data',
                    content: `
                        <div class="d-flex gap-2">
                            <button class="btn btn-outline-primary btn-sm" onclick='showInputDetails("coordinates", ${JSON.stringify(JSON.stringify(queryData))})'>
                                <i class="bi bi-geo-alt"></i> Coordinates
                            </button>
                            <button class="btn btn-outline-primary btn-sm" onclick='showInputDetails("transcripts", ${JSON.stringify(JSON.stringify(queryData))})'>
                                <i class="bi bi-list-ol"></i> Identifiers
                            </button>
                        </div>
                    `
                },
                {
                    icon: 'bi-arrows-expand',
                    title: 'Standard Padding',
                    content: `
                        <div class="parameter-tag">
                            <span class="param-label">Padding:</span>
                            <span class="param-value">${queryData.settings?.padding?.standard || '0'}bp</span>
                        </div>
                    `
                },
                {
                    icon: 'bi-record-circle',
                    title: 'SNP Settings',
                    content: `
                        <div class="parameter-tag">
                            <span class="param-label">SNP Padding:</span>
                            <span class="param-value">${queryData.settings?.padding?.snp || '0'}bp</span>
                        </div>
                        ${queryData.use_separate_snp_padding ? `
                            <div class="parameter-tag">
                                <span class="param-label">5' SNP Padding:</span>
                                <span class="param-value">${queryData.snp_padding_5 || '0'}bp</span>
                            </div>
                            <div class="parameter-tag">
                                <span class="param-label">3' SNP Padding:</span>
                                <span class="param-value">${queryData.snp_padding_3 || '0'}bp</span>
                            </div>
                        ` : ''}
                    `
                },
                {
                    icon: 'bi-gear',
                    title: 'UTR Settings',
                    content: `
                        <div class="d-flex gap-2">
                            <div class="parameter-tag">
                                <span class="param-label">5' UTR:</span>
                                <span class="param-value">${queryData.include_5utr ? 'Yes' : 'No'}</span>
                            </div>
                            <div class="parameter-tag">
                                <span class="param-label">3' UTR:</span>
                                <span class="param-value">${queryData.include_3utr ? 'Yes' : 'No'}</span>
                            </div>
                        </div>
                    `
                }
            ];

            // Create the workflow steps HTML
            const stepsHtml = workflowSteps.map(step => `
                <div class="workflow-step">
                    <div class="step-header">
                        <i class="bi ${step.icon} step-icon"></i>
                        <span class="step-title">${step.title}</span>
                    </div>
                    <div class="step-content">
                        ${step.content}
                    </div>
                </div>
            `).join('');

            return stepsHtml;
        }

        function showRawQuery(queryDataStr) {
            // Parse the stringified data back to an object
            const queryData = JSON.parse(queryDataStr);
            
            // Create a modal for the raw query
            const modalHtml = `
                <div class="modal fade" id="rawQueryModal" tabindex="-1">
                    <div class="modal-dialog modal-lg">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title">Raw Query Details</h5>
                                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                            </div>
                            <div class="modal-body">
                                <pre class="bg-light p-3 rounded"><code>${JSON.stringify(queryData, null, 2)}</code></pre>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // Remove existing modal if it exists
            const existingModal = document.getElementById('rawQueryModal');
            if (existingModal) {
                existingModal.remove();
            }

            // Add the modal to the document
            document.body.insertAdjacentHTML('beforeend', modalHtml);

            // Show the modal
            const modal = new bootstrap.Modal(document.getElementById('rawQueryModal'));
            modal.show();
        }

        function formatParameterTags(parameters) {
            return Object.entries(parameters)
                .map(([key, value]) => `
                    <div class="parameter-tag">
                        <span class="param-label">${formatKeyName(key)}:</span>
                        <span class="param-value">${formatValue(value)}</span>
                    </div>
                `).join('');
        }

        function formatKeyName(key) {
            return key.split('_').map(word => 
                word.charAt(0).toUpperCase() + word.slice(1)
            ).join(' ');
        }

        function formatValue(value) {
            if (typeof value === 'boolean') {
                return value ? 'Yes' : 'No';
            }
            if (typeof value === 'number') {
                return value.toString();
            }
            return value;
        }

        // Add this function to handle showing the data modal
        function showDataModal(title, content) {
            // Remove existing modal if present
            const existingModal = document.getElementById('dataModal');
            if (existingModal) {
                existingModal.remove();
            }

            // Create modal HTML
            const modalHtml = `
                <div class="modal fade" id="dataModal" tabindex="-1">
                    <div class="modal-dialog modal-lg">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title">${title}</h5>
                                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                            </div>
                            <div class="modal-body">
                                <pre class="bg-light p-3 rounded"><code>${content}</code></pre>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // Add modal to document
            document.body.insertAdjacentHTML('beforeend', modalHtml);

            // Show the modal
            const modal = new bootstrap.Modal(document.getElementById('dataModal'));
            modal.show();
        }

        // Updated function to handle re-querying with all original data
        function reQueryData(queryDataStr) {
            try {
                // Parse the stringified query data
                const queryData = JSON.parse(queryDataStr);
                
                // Create a form to submit the data
                const form = document.createElement('form');
                form.method = 'POST';
                form.action = '/bed_generator';

                // Add CSRF token if needed
                const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;
                if (csrfToken) {
                    const csrfInput = document.createElement('input');
                    csrfInput.type = 'hidden';
                    csrfInput.name = 'csrf_token';
                    csrfInput.value = csrfToken;
                    form.appendChild(csrfInput);
                }

                // Add all query parameters as hidden inputs
                Object.entries(queryData).forEach(([key, value]) => {
                    // Skip null, undefined, or empty values
                    if (value == null || value === '') return;
                    
                    // Create input for each parameter
                    const input = document.createElement('input');
                    input.type = 'hidden';
                    input.name = key;
                    input.value = typeof value === 'object' ? JSON.stringify(value) : value;
                    form.appendChild(input);
                });

                // Add the form to the document and submit
                document.body.appendChild(form);
                form.submit();
            } catch (error) {
                console.error('Error processing query data:', error);
                alert('Failed to re-run query. Please try again.');
            }
        }

        // Update the showInputDetails function
        function showInputDetails(type, dataStr) {
            try {
                const data = JSON.parse(dataStr);
                let title = type === 'coordinates' ? 'Coordinate List' : 'Identifier List';
                let content = '';

                if (type === 'coordinates') {
                    content = data.coordinates || 'No coordinates specified';
                } else {
                    content = data.identifiers || 'No identifiers specified';
                }

                if (content === '') {
                    content = `No ${type} specified`;
                }

                // Format content as a list if it's multiple items
                const contentArray = Array.isArray(content) ? content : content.split('\n');
                const formattedList = contentArray
                    .filter(item => item.trim())
                    .map(item => item.trim())
                    .join('\n');

                const formattedContent = `
                    <div class="input-details-container">
                        <pre class="data-display-box"><code class="data-content">${formattedList}</code></pre>
                        <div class="copy-button-container">
                            <button class="btn btn-sm btn-outline-secondary copy-btn" onclick="copyToClipboard(this)">
                                <i class="bi bi-clipboard"></i> Copy to clipboard
                            </button>
                        </div>
                    </div>
                `;

                showDataModal(title, formattedContent);
            } catch (error) {
                console.error('Error processing data:', error);
                showDataModal(type === 'coordinates' ? 'Coordinate List' : 'Identifier List', 'Error processing data');
            }
        }

        // Update the copyToClipboard function
        function copyToClipboard(button, elementId) {
            const content = document.querySelector('.data-content').textContent;
            navigator.clipboard.writeText(content).then(() => {
                const originalHTML = button.innerHTML;
                button.innerHTML = '<i class="bi bi-check"></i> Copied!';
                button.disabled = true;
                setTimeout(() => {
                    button.innerHTML = originalHTML;
                    button.disabled = false;
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
                alert('Failed to copy to clipboard');
            });
        }
    </script>
{% endblock %}
</file>

<file path="app/templates/base.html">
<!DOCTYPE html>
<html lang="en" class="h-100">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}{% endblock %}</title>
    <link rel="shortcut icon" href="{{ url_for('static', filename='favicon.ico') }}">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css">
    <style>
        body {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        .content-wrapper {
            flex: 1 0 auto;
        }
        .footer {
            flex-shrink: 0;
        }
        .navbar-nav .nav-item {
            margin-right: 15px; /* Adjust the value as needed for consistent spacing */
        }
    </style>
</head>

<body>
    <nav class="navbar navbar-expand-lg navbar-custom">
        <div class="container-fluid">
            <div class="logo-container" style="margin-right: 20px;">
                <a href="https://www.synnovis.co.uk/" target="_blank">
                    <img src="{{ url_for('static', filename='images/logo.png') }}" alt="Synnovis Logo" height="40">
                </a>
            </div>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav me-auto">
                    <li class="nav-item dropdown {% if request.blueprint in ['bed_generator', 'bed_manager'] %}active{% endif %}">
                        <a class="nav-link dropdown-toggle {% if request.blueprint in ['bed_generator', 'bed_manager'] %}active{% endif %}" href="#" id="bedGeneratorDropdown" role="button" onclick="toggleDropdown('bedGeneratorMenu')">
                            BED File Manager
                        </a>
                        <ul class="dropdown-menu" id="bedGeneratorMenu" aria-labelledby="bedGeneratorDropdown">
                            <li><a class="dropdown-item {% if request.endpoint == 'bed_generator.index' %}active{% endif %}" href="{{ url_for('bed_generator.index') }}">Generate BEDs</a></li>
                            <li><a class="dropdown-item {% if request.endpoint == 'bed_manager.index' %}active{% endif %}" href="{{ url_for('bed_manager.index') }}">BED Management</a></li>
                            <li><a class="dropdown-item {% if request.endpoint == 'bed_generator.settings' %}active{% endif %}" href="{{ url_for('bed_generator.settings') }}">Settings</a></li>
                        </ul>
                    </li>
                </ul>
            </div>
            <div class="d-flex align-items-center">
                <small class="text-light opacity-75 me-3">v{{ config.VERSION }}</small>
                {% if current_user.is_authenticated %}
                    <div class="nav-item dropdown me-3">
                        <a class="nav-link dropdown-toggle btn btn-custom" href="#" id="userDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                            {{ current_user.username }}
                        </a>
                        <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="userDropdown">
                            {% if current_user.is_authorizer %}
                                <li><a class="dropdown-item" href="{{ url_for('auth.user_management') }}">User Management</a></li>
                            {% endif %}
                            <li><a class="dropdown-item" href="{{ url_for('auth.logout') }}">Log Out</a></li>
                        </ul>
                    </div>
                {% else %}
                    <a class="nav-link btn btn-custom me-3" href="{{ url_for('auth.login') }}">Sign In <i class="bi bi-lock"></i></a>
                {% endif %}
            </div>
        </div>
    </nav>
    
    <div class="content-wrapper">
        <div class="container">
            {% block content %}{% endblock %}
        </div>
    </div>

    <footer class="footer text-center mt-auto py-3">
        <p style="font-size: smaller; font-weight: lighter;">
            <strong>Developed by the Synnovis Bioinformatics Team @ Guy's and St Thomas' NHS Foundation Trust (2024) </strong>
            <a href="https://github.com/moka-guys/bedmakerGUI" target="_blank" style="margin-left: 10px;">
                <i class="bi bi-github"></i>
            </a>
        </p>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    {% block scripts %}{% endblock %}
    <script>
        function toggleDropdown(menuId) {
            var dropdownMenu = document.getElementById(menuId);
            dropdownMenu.classList.toggle('show');
        }

        // Close the dropdown if the user clicks outside of it
        window.onclick = function(event) {
            if (!event.target.matches('.dropdown-toggle')) {
                var dropdowns = document.getElementsByClassName("dropdown-menu");
                for (var i = 0; i < dropdowns.length; i++) {
                    var openDropdown = dropdowns[i];
                    if (openDropdown.classList.contains('show')) {
                        openDropdown.classList.remove('show');
                    }
                }
            }
        }
    </script>
</body>
</html>
</file>

<file path="app/templates/bed_generator.html">
{% extends 'base.html' %}

{% block title %}BEDmaker GUI{% endblock %}

{% block content %}
    <!-- Page Title Card -->
    <div class="card shadow-sm mb-4">
        <div class="card-body text-center bg-light">
            <h4 class="my-1 page-title">BEDmaker GUI</h4>
        </div>
    </div>

    <form method="post" id="bedGeneratorForm">
        {{ form.hidden_tag() }}
        <div class="row">
            <!-- Left Column: Reference and Custom Genomic Ranges -->
            <div class="col-md-6">
                <!-- Reference Card -->
                <div class="mb-4">
                    <div class="card shadow-sm mb-4">
                        <div class="card-header" style="background: linear-gradient(45deg, #f8f9fa, #ffffff);">
                            <i class="bi bi-book" style="padding-right: 5px;"></i>Reference
                        </div>
                        <div class="card-body p-3">
                            <div class="mb-3">
                                {{ form.assembly(class="form-control", id="assembly") }}
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Custom Genomic Ranges Card -->
                <div class="mb-4">
                    <div class="card shadow-sm bg-light">
                        <div class="card-header">
                            <i class="fa-solid fa-file-import" style="padding-right: 5px;"></i>Custom Genomic Range(s)
                            <small style="font-size: 0.8em; color: #6c757d;"><i><br>Optional. Please ensure BED co-ordinates match the assembly chosen.</i></small>
                        </div>
                        <div class="card-body">
                            <div class="mb-3">
                                {{ form.coordinates(class="form-control", rows="3", placeholder="Enter genomic coordinates (e.g., chr1:200-300), one per line", id="coordinates") }}
                                <div id="coordinatesError" class="invalid-feedback"></div>
                            </div>
                            <div class="mb-3">
                                <label for="bedFile" class="form-label">
                                    <small style="font-size: 0.8em; color: #6c757d;"><b>Extract regions from BED File(s)</b></small>
                                </label>
                                {{ form.bedFiles(class="form-control", id="bedFile", accept=".bed", multiple=True) }}
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Column: PanelApp Card -->
            <div class="col-md-6">
                <div class="mb-4">
                    <div class="card shadow-sm bg-light">
                        <div class="card-header">
                            <i class="bi bi-diagram-2-fill" style="padding-right: 5px;"></i>Use PanelApp to import gene list
                        </div>
                        <div class="card-body">
                            <div class="d-flex flex-column align-items-center mb-3">
                                <div class="w-100">
                                    <div class="row mb-3">
                                        <div class="col-md-12">
                                            <label for="searchPanel" class="form-label">Filter</label>
                                            <input type="text" id="searchPanel" class="form-control" placeholder="Type to search..." onkeyup="filterPanels()">
                                        </div>
                                    </div>
                                    <div class="row mb-3">
                                        <div class="col-md-12">
                                            <label for="panelDropdown" class="form-label">Select a panel</label>
                                            <select class="form-control" id="panelDropdown" onchange="updateIdentifiers()">
                                                <option value="">Select a panel...</option>
                                                {% for panel in panels %}
                                                    <option value="{{ panel.id }}">{{ panel.full_name }}</option>
                                                {% endfor %}
                                            </select>
                                            <div id="panelLoadingSpinner" class="spinner-border spinner-border-sm mt-2" role="status" style="display: none;">
                                                <span class="visually-hidden"></span>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="form-check form-check-inline">
                                        <input class="form-check-input" type="checkbox" id="includeAmber" onchange="updateIdentifiers()">
                                        <label class="form-check-label" for="includeAmber">Include amber</label>
                                    </div>
                                    <div class="form-check form-check-inline">
                                        <input class="form-check-input" type="checkbox" id="includeRed" onchange="updateIdentifiers()">
                                        <label class="form-check-label" for="includeRed">Include red</label>
                                    </div>
                                </div>
                            </div>
                            <hr class="my-4">
                            <div class="mb-3 text-center">
                                <button type="button" class="btn btn-success refresh-button" onclick="refreshPanels()">
                                    <span class="button-text">Update PanelApp data</span>
                                    <span class="loading-spinner" style="display: none;">
                                        <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                                    </span>
                                </button>
                                <p class="mt-2 mb-0"><small class="text-muted"><strong><span id="lastUpdated"></span></strong></small></p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Identifiers Card -->
        <div class="card shadow-sm mb-4">
            <div class="card-header" style="background-color: #b9fbd8;">
                <i class="fa-duotone fa-solid fa-dna" style="padding-right: 5px;"></i>Identifiers
                <small style="font-size: 0.8em; color: #6c757d;"><i><br>Enter gene symbols, rsIDs, or RefSeq transcripts</i></small>
            </div>
            <div class="card-body p-3">
                <div class="mb-3">
                    {{ form.identifiers(class="form-control", rows="3", placeholder="Gene symbol, rsID, or RefSeq transcript. Must be separated by commas, spaces, or new lines", id="identifiers") }}
                </div>
                <div class="mb-3">
                    <label for="csvFile" class="form-label"><strong class="text-muted"><small>Upload CSV/TXT file with identifiers</strong> <i>Values separated using either commas or new lines</i></small></label>
                    {{ form.csvFile(class="form-control", id="csvFile", accept=".csv,.txt") }}
                </div>
            </div>
        </div>

        <center>
            {{ form.submit(class="btn btn-primary", id="generateButton") }}
            <div class="spinner-square d-none" id="spinner">
                <div class="square-1 square"></div>
                <div class="square-2 square"></div>
                <div class="square-3 square"></div>
            </div>
        </center>
    </form>

    <!-- EXTERNAL JS -->
    <script src="{{ url_for('static', filename='js/bed_generator.js') }}"></script>

{% endblock %}
</file>

<file path="app/templates/results.html">
{% extends 'base.html' %}

{% block title %}Results{% endblock %}

{% block content %}
<div class="d-flex flex-column">
    <!-- Page Title Card -->
    <div class="card shadow-sm mb-4" style="background-color: #f8f9fa;">
        <div class="card-body text-center" style="background-color: #fafafa;">
            <h3 class="my-1 page-title">Results</h3>
        </div>
    </div>

    <div class="flex-grow-1">
        {% if results %}
            <!-- New Alert Section for Identifiers with No Data -->
            {% if no_data_identifiers %}
            <div class="alert alert-warning" role="alert">
                <strong>Alert:</strong> No data found for the following identifiers: {{ no_data_identifiers|join(', ') }}
            </div>
            {% endif %}

            <!-- New Alert Section for Overlapping Genes -->
            {% set overlapping_alerts = [] %}
            {% for result in results %}
                {% if result.alert and result.alert not in overlapping_alerts %}
                    {% do overlapping_alerts.append(result.alert) %}
                {% endif %}
            {% endfor %}
            {% for alert in overlapping_alerts %}
            <div class="alert alert-warning" role="alert">
                <strong>Alert:</strong> {{ alert }}
            </div>
            {% endfor %}

            <!-- Results Card -->
            <div class="card shadow-sm mb-4">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <span>
                        <i class="fa-solid fa-file-import" style="padding-right: 10px;"></i>BED File Contents
                        <small style="font-size: 0.8em; color: #6c757d;"><i><br>IGV will automatically update when you click on a field.</i></small>
                    </span>
                </div>
                <div class="card-body p-0">
                    <div class="table-responsive" style="max-height: 400px; overflow-y: auto;">
                        <table class="table table-bordered table-striped mb-0">
                            <thead>
                                <tr>
                                    <th>
                                        Chromosome
                                    </th>
                                    <th>Start</th>
                                    <th>End</th>
                                    <th>EntrezID</th>
                                    <th>Gene</th>
                                    <th>Accession</th>
                                    <th>Exon ID</th>
                                    <th>Exon Number</th>
                                    <th>Transcript Biotype</th>
                                    <th>Ensembl Transcript ID</th>
                                    <th>Status</th>
                                </tr>
                            </thead>
                            <tbody>
                                {% for result in results %}
                                    <tr onclick="setActiveRow(this, {{ loop.index0 }})">
                                        <td>{{ result.loc_region }}</td>
                                        <td>{{ result.loc_start }}</td>
                                        <td>{{ result.loc_end }}</td>
                                        <td>{{ result.entrez_id }}</td>
                                        <td style="background-color: #d4edda;">{{ result.gene }}</td>
                                        <td>{{ result.accession }}</td>
                                        <td>{{ result.exon_id }}</td>
                                        <td>{{ result.exon_number }}</td>
                                        <td>{{ result.transcript_biotype }}</td>
                                        <td>{{ result.mane_transcript }}</td>
                                        <td>
                                            {% if result.warning %}
                                                {% if result.warning.type == 'version_specified' %}
                                                    <span class="badge bg-success text-white">
                                                        <i class="fas fa-check"></i> {{ result.warning.message }}
                                                    </span>
                                                {% elif result.warning.type == 'transcript_selection' %}
                                                    <span class="badge bg-info text-white">
                                                        <i class="fas fa-info-circle"></i> GRCh38 MANE SELECT equivalent
                                                    </span>
                                                {% else %}
                                                    <span class="badge bg-warning text-dark">
                                                        <i class="fas fa-exclamation-triangle"></i> 
                                                        {{ result.warning.message if result.warning is mapping else result.warning }}
                                                    </span>
                                                {% endif %}
                                            {% else %}
                                                {% if result.is_snp %}
                                                    <span class="badge bg-info text-white">
                                                        <i class="fas fa-dna"></i> SNP
                                                    </span>
                                                {% elif result.mane_transcript_type == 'MANE Plus Clinical' %}
                                                    <span class="badge bg-primary text-white">
                                                        <i class="fas fa-plus-circle"></i> MANE Plus Clinical
                                                    </span>
                                                {% elif result.mane_transcript_type == 'MANE Select' %}
                                                    <span class="badge bg-success text-white">
                                                        <i class="fas fa-check"></i> MANE Select
                                                    </span>
                                                {% else %}
                                                    <span class="badge bg-success text-white">
                                                        <i class="fas fa-check"></i> Transcript verified
                                                    </span>
                                                {% endif %}
                                            {% endif %}
                                        </td>
                                    </tr>
                                {% endfor %}
                            </tbody>
                        </table>
                    </div>
                    <!-- Add chr prefix toggle below the table -->
                    <div class="p-2 border-top">
                        <div class="form-check form-switch d-inline-flex align-items-center">
                            <input type="checkbox" class="form-check-input" id="addChrPrefix" role="switch" onchange="toggleChrPrefix()">
                            <label class="form-check-label ms-2" for="addChrPrefix">
                                <small style="font-size: 0.8em; color: #6c757d;">Add chr prefix to chromosome numbers</small>
                            </label>
                        </div>
                    </div>
                </div>
            </div>

            <!-- IGV Viewer Card -->
            <div class="card shadow-sm mb-4">
                <div class="card-header">
                    IGV Viewer
                </div>
                <div class="card-body">
                    <div id="igv-div" style="padding-top: 10px; padding-bottom: 10px; border:1px solid lightgray"></div>
                    <div class="mt-3 d-flex justify-content-between">
                        <div>
                            <input type="file" id="bedFileUpload" accept=".bed" style="display: none;">
                            <label for="bedFileUpload" class="btn btn-primary mt-2">Upload existing BED File for comparison</label>
                            <span id="comparisonResult" class="ms-3"></span> <!-- Placeholder for comparison results -->
                        </div>
                        <select id="genome-select" class="form-select d-inline-block w-auto ml-2" onchange="changeGenome()">
                            <option value="hg38" {% if assembly == 'GRCh38' %}selected{% endif %}>hg38</option>
                            <option value="hg19" {% if assembly == 'GRCh37' %}selected{% endif %}>hg19</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- Download and Navigation Buttons -->
            <div class="card shadow-sm mb-4">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <div>
                        <i class="fas fa-download" style="padding-right: 10px;"></i>Options
                    </div>
                </div>
                <div class="card-body">
                    <!-- Buttons section first -->
                    <div class="d-flex justify-content-between align-items-center mb-4">
                        <a href="{{ url_for('bed_generator.index') }}" class="btn btn-secondary">
                            <i class="bi bi-skip-backward"></i> Back
                        </a>
                        
                        <div class="d-flex gap-4">
                            <div class="btn-group">
                                <button class="btn btn-success" onclick="downloadRawBed()">
                                    <i class="bi bi-download"></i> Download BED
                                </button>
                            </div>

                            <div class="btn-group">
                                <button class="btn btn-primary dropdown-toggle" type="button" id="customBedDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                                    <i class="bi bi-gear-fill"></i> Custom BED Files
                                </button>
                                <i class="fas fa-info-circle ms-2" 
                                   style="color: #6c757d; cursor: pointer;" 
                                   onclick="showBedFlowDiagram()"
                                   data-bs-toggle="tooltip" 
                                   data-bs-placement="top"
                                   title="Click for information about BED file generation">
                                </i>
                                <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="customBedDropdown">
                                    <li><small class="dropdown-header text-muted px-3">Custom BED settings configured in Settings</small></li>
                                    <li><hr class="dropdown-divider"></li>
                                    <li>
                                        <a class="dropdown-item" href="#" onclick="downloadCustomBed('data')" data-bs-toggle="tooltip" 
                                           data-bs-html="true" title="
                                           <div style='text-align: left;'>
                                               Padding: {{ settings.data_padding }}bp<br>
                                               SNP Padding: {{ settings.data_snp_padding }}bp<br>
                                               5' UTR: {% if settings.data_include_5utr %}
                                                   <i class='fas fa-check-circle text-success'></i>
                                               {% else %}
                                                   <i class='fas fa-times-circle text-danger'></i>
                                               {% endif %}<br>
                                               3' UTR: {% if settings.data_include_3utr %}
                                                   <i class='fas fa-check-circle text-success'></i>
                                               {% else %}
                                                   <i class='fas fa-times-circle text-danger'></i>
                                               {% endif %}
                                           </div>">.data</a>
                                    </li>
                                    <li>
                                        <a class="dropdown-item" href="#" onclick="downloadCustomBed('sambamba')" data-bs-toggle="tooltip" 
                                           data-bs-html="true" title="
                                           <div style='text-align: left;'>
                                               Padding: {{ settings.sambamba_padding }}bp<br>
                                               SNP Padding: {{ settings.sambamba_snp_padding }}bp<br>
                                               5' UTR: {% if settings.sambamba_include_5utr %}
                                                   <i class='fas fa-check-circle text-success'></i>
                                               {% else %}
                                                   <i class='fas fa-times-circle text-danger'></i>
                                               {% endif %}<br>
                                               3' UTR: {% if settings.sambamba_include_3utr %}
                                                   <i class='fas fa-check-circle text-success'></i>
                                               {% else %}
                                                   <i class='fas fa-times-circle text-danger'></i>
                                               {% endif %}
                                           </div>">.sambamba</a>
                                    </li>
                                    <li>
                                        <a class="dropdown-item" href="#" onclick="downloadCustomBed('exome_depth')" data-bs-toggle="tooltip" 
                                           data-bs-html="true" title="
                                           <div style='text-align: left;'>
                                               Padding: {{ settings.exomeDepth_padding }}bp<br>
                                               SNP Padding: {{ settings.exomeDepth_snp_padding }}bp<br>
                                               5' UTR: {% if settings.exomeDepth_include_5utr %}
                                                   <i class='fas fa-check-circle text-success'></i>
                                               {% else %}
                                                   <i class='fas fa-times-circle text-danger'></i>
                                               {% endif %}<br>
                                               3' UTR: {% if settings.exomeDepth_include_3utr %}
                                                   <i class='fas fa-check-circle text-success'></i>
                                               {% else %}
                                                   <i class='fas fa-times-circle text-danger'></i>
                                               {% endif %}
                                           </div>">.exomeDepth</a>
                                    </li>
                                    <li>
                                        <a class="dropdown-item" href="#" onclick="downloadCustomBed('cnv')" data-bs-toggle="tooltip" 
                                           data-bs-html="true" title="
                                           <div style='text-align: left;'>
                                               Padding: {{ settings.cnv_padding }}bp<br>
                                               SNP Padding: {{ settings.cnv_snp_padding }}bp<br>
                                               5' UTR: {% if settings.cnv_include_5utr %}
                                                   <i class='fas fa-check-circle text-success'></i>
                                               {% else %}
                                                   <i class='fas fa-times-circle text-danger'></i>
                                               {% endif %}<br>
                                               3' UTR: {% if settings.cnv_include_3utr %}
                                                   <i class='fas fa-check-circle text-success'></i>
                                               {% else %}
                                                   <i class='fas fa-times-circle text-danger'></i>
                                               {% endif %}
                                           </div>">.cnv</a>
                                    </li>
                                </ul>
                            </div>
                        </div>

                        <button class="btn btn-danger" onclick="showSubmitModal()" data-index-url="{{ url_for('bed_generator.index') }}">
                            <i class="bi bi-pen"></i> Submit for Review
                        </button>
                    </div>

                    <!-- Horizontal divider -->
                    <hr>
                    <!-- Modifications section below -->
                    <div class="mt-3">
                        <div class="d-flex align-items-center mb-2">
                            <small class="text-muted">
                                <i class="fas fa-info-circle me-1"></i>
                                These modifications only apply to the base BED file download. Custom BED profile settings are managed in Settings.
                            </small>
                        </div>
                        <div class="d-flex flex-wrap gap-4 align-items-center">
                            <div class="form-check form-check-inline mb-0">
                                <input class="form-check-input" type="checkbox" id="showPaddingAdjustment">
                                <label class="form-check-label text-muted" for="showPaddingAdjustment">
                                    <small style="font-size: 0.8em; color: #6c757d;">Show padding options</small>
                                </label>
                            </div>
                            
                            <div class="form-check form-switch d-inline-flex align-items-center">
                                <input type="checkbox" class="form-check-input" id="include5UTR" role="switch" onchange="toggleUTR('5')">
                                <label class="form-check-label ms-2" for="include5UTR">
                                    <small style="font-size: 0.8em; color: #6c757d;">5' UTR</small>
                                </label>
                            </div>

                            <div class="form-check form-switch d-inline-flex align-items-center">
                                <input type="checkbox" class="form-check-input" id="include3UTR" role="switch" onchange="toggleUTR('3')">
                                <label class="form-check-label ms-2" for="include3UTR">
                                    <small style="font-size: 0.8em; color: #6c757d;">3' UTR</small>
                                </label>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Padding Adjustment Section (initially hidden) -->
            <div id="paddingAdjustmentSection" class="card shadow-sm mb-4" style="display: none; margin-top: 20px;">
                <div class="card-header">
                    <i class="fas fa-cog" style="padding-right: 10px;"></i> Adjust BED Padding
                    <small style="font-size: 0.8em; color: #6c757d;"><i><br>Note: These padding adjustments only apply to the Base BED file. Custom BED file padding is managed in Settings.</i></small>
                </div>
                <div class="card-body" style="padding-top: 10px; padding-bottom: 10px;">
                    <div class="mb-3">
                        <label for="paddingInput5" class="form-label">5' Padding (bp)</label>
                        <input type="number" class="form-control" id="paddingInput5" value="0">
                    </div>
                    <div class="mb-3">
                        <label for="paddingInput3" class="form-label">3' Padding (bp)</label>
                        <input type="number" class="form-control" id="paddingInput3" value="0">
                    </div>
                    <div class="mb-3">
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="separateSnpPadding">
                            <label class="form-check-label" for="separateSnpPadding">
                                Use separate padding for SNPs
                            </label>
                        </div>
                        <div id="snpPaddingInputs" style="display: none;">
                            <hr>
                            <label for="snpPadding5" class="form-label">SNP 5' Padding (bp)</label>
                            <input type="number" class="form-control" id="snpPadding5" value="0">
                            <label for="snpPadding3" class="form-label">SNP 3' Padding (bp)</label>
                            <input type="number" class="form-control" id="snpPadding3" value="0">
                        </div>
                    </div>
                    <button class="btn btn-primary" onclick="applyPadding()">Apply Padding</button>
                </div>
            </div>

            <!-- JavaScript to toggle visibility -->
            <script>
                document.getElementById('showPaddingAdjustment').addEventListener('change', function() {
                    var paddingSection = document.getElementById('paddingAdjustmentSection');
                    paddingSection.style.display = this.checked ? 'block' : 'none';
                });
            </script>

            <textarea id="bedContent" style="display: none;">{{ results | tojson }}</textarea>

            <!-- Simplify the modal for file name input -->
            <div class="modal fade" id="submitModal" tabindex="-1" aria-labelledby="submitModalLabel" aria-hidden="true">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title" id="submitModalLabel">Submit BED File for Review</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            <div class="mb-3">
                                <label for="bedFileName" class="form-label">Enter a name for your new BED file:</label>
                                <input type="text" class="form-control" id="bedFileName" required>
                            </div>
                            <div class="form-check mb-3">
                                <input type="checkbox" class="form-check-input" id="baseOnly">
                                <label class="form-check-label" for="baseOnly">
                                    Submit base BED only (skip custom BED types)
                                </label>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                            <button type="button" class="btn btn-primary" onclick="submitForReview()">Submit</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Unique Regions Modal -->
            <div class="modal fade" id="uniqueRegionsModal" tabindex="-1" aria-labelledby="uniqueRegionsModalLabel" aria-hidden="true">
                <div class="modal-dialog modal-lg">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title" id="uniqueRegionsModalLabel">Unique Regions</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            <ul id="uniqueRegionsList" class="list-group"></ul>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- MANE Plus Clinical Selection Modal -->
            <div class="modal fade" id="maneSelectionModal" tabindex="-1" aria-labelledby="maneSelectionModalLabel" aria-hidden="true">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title" id="maneSelectionModalLabel">Select MANE Transcript</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            <p>Multiple transcripts are available for this gene. Please select which transcript you would like to use:</p>
                            <div id="transcriptOptions"></div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-primary" onclick="applyTranscriptSelection()">Apply Selection</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- EXTERNAL JS -->
            <script src="https://cdn.jsdelivr.net/npm/igv@2.10.5/dist/igv.min.js"></script>
            <script src="{{ url_for('static', filename='js/results.js') }}"></script>
            <input type="hidden" id="initialQuery" value="{{ initial_query | tojson | safe }}">
            <script>
                var initialQuery = {{ initial_query | safe }};
            </script>
        {% else %}
            <p>No results found.</p>
        {% endif %}
    </div>
</div>
{% endblock %}

{% block head %}
{{ super() }}
{% endblock %}
</file>

<file path="app/templates/settings.html">
{% extends 'base.html' %}

{% block title %}BED Generator Settings{% endblock %}

{% block content %}
    <!-- Page Title -->
    <div class="card shadow-sm mb-4">
        <div class="card-body text-center">
            <h4 class="my-1 page-title">BED Generator Settings</h4>
        </div>
    </div>

    <!-- Flash Messages -->
    {% with messages = get_flashed_messages(with_categories=true) %}
        {% if messages %}
            {% for category, message in messages %}
                <div class="alert alert-{{ category }} alert-dismissible fade show" role="alert">
                    {{ message }}
                    <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                </div>
            {% endfor %}
        {% endif %}
    {% endwith %}

    <!-- Settings Form -->
    <div class="card shadow-sm">
        <div class="card-header">
            <i class="fa-solid fa-gear" style="padding-right: 5px;"></i>Settings
        </div>
        <div class="card-body pt-4">
            <form id="settingsForm" method="post" action="{{ url_for('bed_generator.settings') }}">
                {{ form.hidden_tag() }}
                
                <!-- Settings Grid -->
                <div class="row">
                    <!-- BED Type Column -->
                    <div class="col-md-3 mb-4">
                        <div class="list-group" id="bed-types" role="tablist" style="background-color: #f8f9fa; padding: 15px; border-radius: 5px;">
                            <a class="list-group-item list-group-item-action active" data-bs-toggle="list" href="#data-bed" role="tab">Data BED</a>
                            <a class="list-group-item list-group-item-action" data-bs-toggle="list" href="#sambamba-bed" role="tab">Sambamba BED</a>
                            <a class="list-group-item list-group-item-action" data-bs-toggle="list" href="#exomedepth-bed" role="tab">ExomeDepth BED</a>
                            <a class="list-group-item list-group-item-action" data-bs-toggle="list" href="#cnv-bed" role="tab">CNV BED</a>
                        </div>
                    </div>

                    <!-- Settings Content Column -->
                    <div class="col-md-9">
                        <div class="tab-content" style="background-color: #f8f9fa; padding: 20px; border-radius: 5px;">
                            {% for bed_type in ['data', 'sambamba', 'exomeDepth', 'cnv'] %}
                                <div class="tab-pane fade {% if loop.first %}show active{% endif %}" 
                                     id="{{ bed_type|lower }}-bed" role="tabpanel">
                                    <h5 class="mb-4" style="color: #2c3e50; border-bottom: 2px solid #dee2e6; padding-bottom: 8px;">
                                        {{ bed_type }} BED Settings
                                    </h5>
                                    
                                    <!-- Exon Padding Setting -->
                                    <div class="mb-4">
                                        <label class="form-label">Exon Padding</label>
                                        {{ form[bed_type + '_padding'](class="form-control", value=form[bed_type + '_padding'].data or 0) }}
                                        {% if form[bed_type + '_padding'].errors %}
                                            {% for error in form[bed_type + '_padding'].errors %}
                                                <div class="invalid-feedback d-block">{{ error }}</div>
                                            {% endfor %}
                                        {% endif %}
                                    </div>

                                    <!-- SNP Padding Setting -->
                                    <div class="mb-4">
                                        <label class="form-label">SNP Padding</label>
                                        {{ form[bed_type + '_snp_padding'](class="form-control", value=form[bed_type + '_snp_padding'].data or 0) }}
                                        {% if form[bed_type + '_snp_padding'].errors %}
                                            {% for error in form[bed_type + '_snp_padding'].errors %}
                                                <div class="invalid-feedback d-block">{{ error }}</div>
                                            {% endfor %}
                                        {% endif %}
                                    </div>

                                    <!-- UTR Settings -->
                                    <div class="card" style="background-color: white;">
                                        <div class="card-body" style="background-color: #f0f0f0;">
                                            <h6 class="card-title">UTR Settings</h6>
                                            <div class="row g-3">
                                                <div class="col-md-6">
                                                    <div class="form-check">
                                                        {{ form[bed_type + '_include_5utr'](class="form-check-input") }}
                                                        <label class="form-check-label">Include 5' UTR</label>
                                                    </div>
                                                </div>
                                                <div class="col-md-6">
                                                    <div class="form-check">
                                                        {{ form[bed_type + '_include_3utr'](class="form-check-input") }}
                                                        <label class="form-check-label">Include 3' UTR</label>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            {% endfor %}
                        </div>
                    </div>
                </div>

                <!-- Submit Button -->
                <div class="mt-4 text-end">
                    {{ form.submit(class="btn btn-primary px-4") }}
                </div>
            </form>
        </div>
    </div>
{% endblock %}
</file>

<file path="app/__init__.py">
import os
from flask import Flask
from flask_bootstrap import Bootstrap
from flask_session import Session
from config import Config
from .extensions import db, login_manager, migrate
import logging
from logging.handlers import RotatingFileHandler

def create_app(config_class=Config):
    app = Flask(__name__)
    app.config.from_object(config_class)
    
    # Initialize extensions
    Bootstrap(app)
    Session(app)
    db.init_app(app)
    login_manager.init_app(app)
    migrate.init_app(app, db)

    login_manager.login_view = 'auth.login'

    # Register blueprints
    from app.bed_generator import bed_generator_bp
    from app.bed_manager import bed_manager_bp
    from app.auth import auth_bp

    app.register_blueprint(bed_generator_bp, url_prefix='/bed_generator')
    app.register_blueprint(bed_manager_bp, url_prefix='/bed_manager')
    app.register_blueprint(auth_bp, url_prefix='/auth')

    # Set up logging
    if not app.debug and not app.testing:
        if not os.path.exists('logs'):
            os.mkdir('logs')
        file_handler = RotatingFileHandler('logs/bed_generator.log', maxBytes=10240, backupCount=10)
        file_handler.setFormatter(logging.Formatter(
            '%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'
        ))
        file_handler.setLevel(logging.INFO)
        app.logger.addHandler(file_handler)

        app.logger.setLevel(logging.INFO)
        app.logger.info('BED Generator startup')

    @app.context_processor
    def inject_version():
        return dict(app_version=app.config['VERSION'])

    return app

from app import models

@login_manager.user_loader
def load_user(user_id):
    return models.User.query.get(int(user_id))
</file>

<file path="app/extensions.py">
from flask_sqlalchemy import SQLAlchemy
from flask_login import LoginManager
from flask_migrate import Migrate

db = SQLAlchemy()
login_manager = LoginManager()
migrate = Migrate()
</file>

<file path="app/forms.py">
from flask_wtf import FlaskForm
from wtforms import IntegerField, SubmitField, SelectField, TextAreaField, FileField, BooleanField
from wtforms.validators import DataRequired, NumberRange, Optional, InputRequired

class SettingsForm(FlaskForm):
    data_padding = IntegerField('Data Padding', validators=[InputRequired(), NumberRange(min=0, message="Padding must be 0 or greater")], default=0)
    sambamba_padding = IntegerField('Sambamba Padding', validators=[InputRequired(), NumberRange(min=0, message="Padding must be 0 or greater")], default=0)
    exomeDepth_padding = IntegerField('ExomeDepth Padding', validators=[InputRequired(), NumberRange(min=0, message="Padding must be 0 or greater")], default=0)
    cnv_padding = IntegerField('CNV Padding', validators=[InputRequired(), NumberRange(min=0, message="Padding must be 0 or greater")], default=0)
    data_snp_padding = IntegerField('Data SNP Padding', validators=[InputRequired(), NumberRange(min=0, message="SNP padding must be 0 or greater")], default=0)
    sambamba_snp_padding = IntegerField('Sambamba SNP Padding', validators=[InputRequired(), NumberRange(min=0, message="SNP padding must be 0 or greater")], default=0)
    exomeDepth_snp_padding = IntegerField('ExomeDepth SNP Padding', validators=[InputRequired(), NumberRange(min=0, message="SNP padding must be 0 or greater")], default=0)
    cnv_snp_padding = IntegerField('CNV SNP Padding', validators=[InputRequired(), NumberRange(min=0, message="SNP padding must be 0 or greater")], default=0)
    data_include_5utr = BooleanField("Include 5' UTR for Data BED")
    data_include_3utr = BooleanField("Include 3' UTR for Data BED")
    sambamba_include_5utr = BooleanField("Include 5' UTR for Sambamba BED")
    sambamba_include_3utr = BooleanField("Include 3' UTR for Sambamba BED")
    exomeDepth_include_5utr = BooleanField("Include 5' UTR for ExomeDepth BED")
    exomeDepth_include_3utr = BooleanField("Include 3' UTR for ExomeDepth BED")
    cnv_include_5utr = BooleanField("Include 5' UTR for CNV BED")
    cnv_include_3utr = BooleanField("Include 3' UTR for CNV BED")
    submit = SubmitField('Save Settings')

class BedGeneratorForm(FlaskForm):
    assembly = SelectField('Assembly', choices=[('GRCh37', 'GRCh37 (hg19)'), ('GRCh38', 'GRCh38 (hg38)')], validators=[DataRequired()])
    coordinates = TextAreaField('Coordinates', validators=[Optional()])
    bedFiles = FileField('BED Files', validators=[Optional()])
    csvFile = FileField('CSV/TXT File', validators=[Optional()])
    identifiers = TextAreaField('Identifiers', validators=[Optional()])
    include5UTR = BooleanField("Include 5' UTR", default=False)
    include3UTR = BooleanField("Include 3' UTR", default=False)
    padding_5 = IntegerField("5' Padding", validators=[Optional()])
    padding_3 = IntegerField("3' Padding", validators=[Optional()])
    submit = SubmitField('Generate BED File')
</file>

<file path="app/models.py">
"""
models.py - Defines the database models for the application.

Models:
- User: Represents user accounts with authentication and role information.
- BedFile: Represents a BED file submission, including metadata and processing status.
- BedEntry: Represents individual entries within a BED file, containing genomic information.
- Settings: Stores application-wide settings, particularly padding values for various operations.

Each model corresponds to a table in the database and includes relationships and methods
as needed for the application's functionality.
"""

from .extensions import db
from flask_login import UserMixin
from werkzeug.security import generate_password_hash, check_password_hash
import json
from typing import List, Dict

class User(UserMixin, db.Model):
    __tablename__ = 'user'
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(64), index=True, unique=True)
    email = db.Column(db.String(120), index=True, unique=True)
    password_hash = db.Column(db.String(128))
    is_authorizer = db.Column(db.Boolean, default=False)
    role = db.Column(db.String(120), index=True, unique=True)

    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)

class BedFile(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    filename = db.Column(db.String(128))
    status = db.Column(db.String(20), default='pending')
    submitter_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    authorizer_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    created_at = db.Column(db.DateTime, default=db.func.current_timestamp())
    updated_at = db.Column(db.DateTime, default=db.func.current_timestamp(), onupdate=db.func.current_timestamp())
    assembly = db.Column(db.String(10), default='GRCh38')
    initial_query = db.Column(db.Text)
    include_3utr = db.Column(db.Boolean, default=False)
    include_5utr = db.Column(db.Boolean, default=False)
    warning = db.Column(db.Text)

    submitter = db.relationship('User', foreign_keys=[submitter_id], backref='submitted_bed_files')
    authorizer = db.relationship('User', foreign_keys=[authorizer_id], backref='authorized_bed_files')
    entries = db.relationship('BedEntry', back_populates='bed_file', cascade='all, delete-orphan')

class BedEntry(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    bed_file_id = db.Column(db.Integer, db.ForeignKey('bed_file.id'), nullable=False)
    chromosome = db.Column(db.String(50))
    start = db.Column(db.Integer)
    end = db.Column(db.Integer)
    entrez_id = db.Column(db.String(50))
    gene = db.Column(db.String(100))
    accession = db.Column(db.String(50))
    exon_id = db.Column(db.String(50))
    exon_number = db.Column(db.Integer)
    transcript_biotype = db.Column(db.String(50))
    mane_transcript = db.Column(db.String(50))
    status = db.Column(db.String(100))

    bed_file = db.relationship('BedFile', back_populates='entries')

    @classmethod
    def create_entries(cls, bed_file_id: int, results: List[Dict]) -> List['BedEntry']:
        """Creates BED entries for a given file ID."""
        entries = []
        for result in results:
            entry = cls(
                bed_file_id=bed_file_id,
                chromosome=result['loc_region'],
                start=result['loc_start'],
                end=result['loc_end'],
                entrez_id=result['entrez_id'],
                gene=result['gene'],
                accession=result['accession'],
                exon_id=result.get('exon_id'),
                exon_number=result.get('exon_number'),
                transcript_biotype=result.get('transcript_biotype'),
                mane_transcript=result.get('mane_transcript'),
                status=result.get('status')
            )
            entries.append(entry)
            db.session.add(entry)
        return entries

class Settings(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    data_padding = db.Column(db.Integer, default=0)
    sambamba_padding = db.Column(db.Integer, default=0)
    exomeDepth_padding = db.Column(db.Integer, default=0)
    cnv_padding = db.Column(db.Integer, default=0)
    data_include_5utr = db.Column(db.Boolean, default=False)
    data_include_3utr = db.Column(db.Boolean, default=False)
    sambamba_include_5utr = db.Column(db.Boolean, default=False)
    sambamba_include_3utr = db.Column(db.Boolean, default=False)
    exomeDepth_include_5utr = db.Column(db.Boolean, default=False)
    exomeDepth_include_3utr = db.Column(db.Boolean, default=False)
    cnv_include_5utr = db.Column(db.Boolean, default=False)
    cnv_include_3utr = db.Column(db.Boolean, default=False)
    data_snp_padding = db.Column(db.Integer, default=0, nullable=False)
    sambamba_snp_padding = db.Column(db.Integer, default=0, nullable=False)
    exomeDepth_snp_padding = db.Column(db.Integer, default=0, nullable=False)
    cnv_snp_padding = db.Column(db.Integer, default=0, nullable=False)

    @classmethod
    def get_settings(cls):
        settings = cls.query.first()
        if not settings:
            settings = cls()
            db.session.add(settings)
            db.session.commit()
        return settings

    def to_dict(self):
        return {
            'data_padding': self.data_padding,
            'sambamba_padding': self.sambamba_padding,
            'exomeDepth_padding': self.exomeDepth_padding,
            'cnv_padding': self.cnv_padding,
            'data_include_5utr': self.data_include_5utr,
            'data_include_3utr': self.data_include_3utr,
            'sambamba_include_5utr': self.sambamba_include_5utr,
            'sambamba_include_3utr': self.sambamba_include_3utr,
            'exomeDepth_include_5utr': self.exomeDepth_include_5utr,
            'exomeDepth_include_3utr': self.exomeDepth_include_3utr,
            'cnv_include_5utr': self.cnv_include_5utr,
            'cnv_include_3utr': self.cnv_include_3utr,
            'data_snp_padding': self.data_snp_padding,
            'sambamba_snp_padding': self.sambamba_snp_padding,
            'exomeDepth_snp_padding': self.exomeDepth_snp_padding,
            'cnv_snp_padding': self.cnv_snp_padding
        }

    def update_from_form(self, form):
        """Updates settings from form data."""
        fields = [
            'data_padding', 'sambamba_padding', 'exomeDepth_padding', 'cnv_padding',
            'data_include_5utr', 'data_include_3utr',
            'sambamba_include_5utr', 'sambamba_include_3utr',
            'exomeDepth_include_5utr', 'exomeDepth_include_3utr',
            'cnv_include_5utr', 'cnv_include_3utr',
            'data_snp_padding', 'sambamba_snp_padding', 'exomeDepth_snp_padding', 'cnv_snp_padding'
        ]
        for field in fields:
            setattr(self, field, getattr(form, field).data)
        db.session.commit()

    def populate_form(self, form):
        """Populates a form with current settings values."""
        fields = [
            'data_padding', 'sambamba_padding', 'exomeDepth_padding', 'cnv_padding',
            'data_snp_padding', 'sambamba_snp_padding', 'exomeDepth_snp_padding', 'cnv_snp_padding',
            'data_include_5utr', 'data_include_3utr',
            'sambamba_include_5utr', 'sambamba_include_3utr',
            'exomeDepth_include_5utr', 'exomeDepth_include_3utr',
            'cnv_include_5utr', 'cnv_include_3utr'
        ]
        for field in fields:
            value = getattr(self, field)
            if value is None and 'padding' in field:
                value = 0  # Set default value for padding fields
            if hasattr(form, field):
                getattr(form, field).data = value
</file>

<file path="migrations/versions/03052354c8b6_add_utr_settings_for_bed_types.py">
"""Add UTR settings for BED types

Revision ID: 03052354c8b6
Revises: c73425212377
Create Date: <timestamp>

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '03052354c8b6'
down_revision = 'c73425212377'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('settings', schema=None) as batch_op:
        # Add UTR columns
        batch_op.add_column(sa.Column('data_include_5utr', sa.Boolean(), nullable=True, server_default='0'))
        batch_op.add_column(sa.Column('data_include_3utr', sa.Boolean(), nullable=True, server_default='0'))
        batch_op.add_column(sa.Column('sambamba_include_5utr', sa.Boolean(), nullable=True, server_default='0'))
        batch_op.add_column(sa.Column('sambamba_include_3utr', sa.Boolean(), nullable=True, server_default='0'))
        batch_op.add_column(sa.Column('exomeDepth_include_5utr', sa.Boolean(), nullable=True, server_default='0'))
        batch_op.add_column(sa.Column('exomeDepth_include_3utr', sa.Boolean(), nullable=True, server_default='0'))
        batch_op.add_column(sa.Column('cnv_include_5utr', sa.Boolean(), nullable=True, server_default='0'))
        batch_op.add_column(sa.Column('cnv_include_3utr', sa.Boolean(), nullable=True, server_default='0'))

        # Add padding columns back (they will be populated from profile_settings)
        batch_op.add_column(sa.Column('data_padding', sa.Integer(), nullable=True, server_default='0'))
        batch_op.add_column(sa.Column('sambamba_padding', sa.Integer(), nullable=True, server_default='0'))
        batch_op.add_column(sa.Column('exomeDepth_padding', sa.Integer(), nullable=True, server_default='0'))
        batch_op.add_column(sa.Column('cnv_padding', sa.Integer(), nullable=True, server_default='0'))

    # Migrate data from profile_settings to individual columns
    connection = op.get_bind()
    settings_table = sa.Table(
        'settings',
        sa.MetaData(),
        sa.Column('id', sa.Integer()),
        sa.Column('profile_settings', sa.JSON()),
        sa.Column('data_padding', sa.Integer()),
        sa.Column('sambamba_padding', sa.Integer()),
        sa.Column('exomeDepth_padding', sa.Integer()),
        sa.Column('cnv_padding', sa.Integer())
    )
    
    for settings in connection.execute(settings_table.select()):
        if settings.profile_settings:
            profile_settings = settings.profile_settings
            connection.execute(
                settings_table.update().
                where(settings_table.c.id == settings.id).
                values(
                    data_padding=profile_settings.get('data', {}).get('padding', 0),
                    sambamba_padding=profile_settings.get('sambamba', {}).get('padding', 0),
                    exomeDepth_padding=profile_settings.get('exome_depth', {}).get('padding', 0),
                    cnv_padding=profile_settings.get('cnv', {}).get('padding', 0)
                )
            )

    # Drop profile_settings column
    with op.batch_alter_table('settings', schema=None) as batch_op:
        batch_op.drop_column('profile_settings')


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('settings', schema=None) as batch_op:
        # Recreate profile_settings column
        batch_op.add_column(sa.Column('profile_settings', sa.JSON(), nullable=True))

        # Drop UTR columns
        batch_op.drop_column('cnv_include_3utr')
        batch_op.drop_column('cnv_include_5utr')
        batch_op.drop_column('exomeDepth_include_3utr')
        batch_op.drop_column('exomeDepth_include_5utr')
        batch_op.drop_column('sambamba_include_3utr')
        batch_op.drop_column('sambamba_include_5utr')
        batch_op.drop_column('data_include_3utr')
        batch_op.drop_column('data_include_5utr')

        # Drop padding columns
        batch_op.drop_column('cnv_padding')
        batch_op.drop_column('exomeDepth_padding')
        batch_op.drop_column('sambamba_padding')
        batch_op.drop_column('data_padding')

    # ### end Alembic commands ###
</file>

<file path="migrations/versions/2363d18d116a_add_role_column_to_user_table.py">
"""Add role column to user table

Revision ID: 2363d18d116a
Revises: 
Create Date: 2024-10-13 15:23:22.695726

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '2363d18d116a'
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('user', schema=None) as batch_op:
        batch_op.add_column(sa.Column('role', sa.String(length=120), nullable=True))
        batch_op.create_index(batch_op.f('ix_user_role'), ['role'], unique=True)
        batch_op.drop_column('job_role')

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('user', schema=None) as batch_op:
        batch_op.add_column(sa.Column('job_role', sa.VARCHAR(length=64), nullable=True))
        batch_op.drop_index(batch_op.f('ix_user_role'))
        batch_op.drop_column('role')

    # ### end Alembic commands ###
</file>

<file path="migrations/versions/3467b49b34cd_add_snp_padding_settings.py">
"""Add SNP padding settings

Revision ID: 3467b49b34cd
Revises: ebb20169be05
Create Date: 2024-11-26 10:42:26.474144

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '3467b49b34cd'
down_revision = 'ebb20169be05'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('settings', schema=None) as batch_op:
        batch_op.add_column(sa.Column('data_snp_padding', sa.Integer(), nullable=True))
        batch_op.add_column(sa.Column('sambamba_snp_padding', sa.Integer(), nullable=True))
        batch_op.add_column(sa.Column('exomeDepth_snp_padding', sa.Integer(), nullable=True))
        batch_op.add_column(sa.Column('cnv_snp_padding', sa.Integer(), nullable=True))

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('settings', schema=None) as batch_op:
        batch_op.drop_column('cnv_snp_padding')
        batch_op.drop_column('exomeDepth_snp_padding')
        batch_op.drop_column('sambamba_snp_padding')
        batch_op.drop_column('data_snp_padding')

    # ### end Alembic commands ###
</file>

<file path="migrations/versions/35d6835fbaf8_add_utr_inclusion_columns_to_bedfile.py">
"""Add UTR inclusion columns to BedFile

Revision ID: 35d6835fbaf8
Revises: 4ee76151a4b6
Create Date: 2024-10-17 17:19:52.735406

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '35d6835fbaf8'
down_revision = '4ee76151a4b6'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('bed_file', schema=None) as batch_op:
        batch_op.add_column(sa.Column('include_3utr', sa.Boolean(), nullable=True))
        batch_op.add_column(sa.Column('include_5utr', sa.Boolean(), nullable=True))

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('bed_file', schema=None) as batch_op:
        batch_op.drop_column('include_5utr')
        batch_op.drop_column('include_3utr')

    # ### end Alembic commands ###
</file>

<file path="migrations/versions/4ee76151a4b6_add_initial_query_to_bedfile.py">
"""Add initial_query to BedFile

Revision ID: 4ee76151a4b6
Revises: 6ed3cbad7b03
Create Date: 2024-10-14 11:16:42.242486

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '4ee76151a4b6'
down_revision = '6ed3cbad7b03'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('bed_file', schema=None) as batch_op:
        batch_op.add_column(sa.Column('initial_query', sa.Text(), nullable=True))

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('bed_file', schema=None) as batch_op:
        batch_op.drop_column('initial_query')

    # ### end Alembic commands ###
</file>

<file path="migrations/versions/6a06a48e6f48_add_exporttype_model_and_update_settings.py">
"""Add ExportType model and update Settings

Revision ID: 6a06a48e6f48
Revises: a082711d385e
Create Date: 2024-11-13 17:09:45.893244

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '6a06a48e6f48'
down_revision = 'a082711d385e'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('settings', schema=None) as batch_op:
        batch_op.drop_column('sambamba_padding')
        batch_op.drop_column('data_padding')
        batch_op.drop_column('exomeDepth_padding')
        batch_op.drop_column('cnv_padding')

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('settings', schema=None) as batch_op:
        batch_op.add_column(sa.Column('cnv_padding', sa.INTEGER(), nullable=True))
        batch_op.add_column(sa.Column('exomeDepth_padding', sa.INTEGER(), nullable=True))
        batch_op.add_column(sa.Column('data_padding', sa.INTEGER(), nullable=True))
        batch_op.add_column(sa.Column('sambamba_padding', sa.INTEGER(), nullable=True))

    # ### end Alembic commands ###
</file>

<file path="migrations/versions/6ed3cbad7b03_add_assembly_column_to_bed_file_table.py">
"""Add assembly column to bed_file table

Revision ID: 6ed3cbad7b03
Revises: 2363d18d116a
Create Date: 2024-10-14 11:04:15.398836

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '6ed3cbad7b03'
down_revision = '2363d18d116a'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('bed_file', schema=None) as batch_op:
        batch_op.add_column(sa.Column('assembly', sa.String(length=10), nullable=True))

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('bed_file', schema=None) as batch_op:
        batch_op.drop_column('assembly')

    # ### end Alembic commands ###
</file>

<file path="migrations/versions/85f66015e00d_add_snp_padding_fields.py">
"""Add SNP padding fields

Revision ID: 85f66015e00d
Revises: 3467b49b34cd
Create Date: 2024-11-26 10:49:55.346540

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '85f66015e00d'
down_revision = '3467b49b34cd'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('_alembic_tmp_settings')
    with op.batch_alter_table('settings', schema=None) as batch_op:
        batch_op.alter_column('data_snp_padding',
               existing_type=sa.INTEGER(),
               nullable=False)
        batch_op.alter_column('sambamba_snp_padding',
               existing_type=sa.INTEGER(),
               nullable=False)
        batch_op.alter_column('exomeDepth_snp_padding',
               existing_type=sa.INTEGER(),
               nullable=False)
        batch_op.alter_column('cnv_snp_padding',
               existing_type=sa.INTEGER(),
               nullable=False)

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('settings', schema=None) as batch_op:
        batch_op.alter_column('cnv_snp_padding',
               existing_type=sa.INTEGER(),
               nullable=True)
        batch_op.alter_column('exomeDepth_snp_padding',
               existing_type=sa.INTEGER(),
               nullable=True)
        batch_op.alter_column('sambamba_snp_padding',
               existing_type=sa.INTEGER(),
               nullable=True)
        batch_op.alter_column('data_snp_padding',
               existing_type=sa.INTEGER(),
               nullable=True)

    op.create_table('_alembic_tmp_settings',
    sa.Column('id', sa.INTEGER(), nullable=False),
    sa.Column('data_include_5utr', sa.BOOLEAN(), server_default=sa.text("'0'"), nullable=True),
    sa.Column('data_include_3utr', sa.BOOLEAN(), server_default=sa.text("'0'"), nullable=True),
    sa.Column('sambamba_include_5utr', sa.BOOLEAN(), server_default=sa.text("'0'"), nullable=True),
    sa.Column('sambamba_include_3utr', sa.BOOLEAN(), server_default=sa.text("'0'"), nullable=True),
    sa.Column('exomeDepth_include_5utr', sa.BOOLEAN(), server_default=sa.text("'0'"), nullable=True),
    sa.Column('exomeDepth_include_3utr', sa.BOOLEAN(), server_default=sa.text("'0'"), nullable=True),
    sa.Column('cnv_include_5utr', sa.BOOLEAN(), server_default=sa.text("'0'"), nullable=True),
    sa.Column('cnv_include_3utr', sa.BOOLEAN(), server_default=sa.text("'0'"), nullable=True),
    sa.Column('data_padding', sa.INTEGER(), server_default=sa.text("'0'"), nullable=True),
    sa.Column('sambamba_padding', sa.INTEGER(), server_default=sa.text("'0'"), nullable=True),
    sa.Column('exomeDepth_padding', sa.INTEGER(), server_default=sa.text("'0'"), nullable=True),
    sa.Column('cnv_padding', sa.INTEGER(), server_default=sa.text("'0'"), nullable=True),
    sa.Column('data_snp_padding', sa.INTEGER(), nullable=False),
    sa.Column('sambamba_snp_padding', sa.INTEGER(), nullable=False),
    sa.Column('exomeDepth_snp_padding', sa.INTEGER(), nullable=False),
    sa.Column('cnv_snp_padding', sa.INTEGER(), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )
    # ### end Alembic commands ###
</file>

<file path="migrations/versions/a082711d385e_add_warning_column_to_bed_file_table.py">
"""Add warning column to bed_file table

Revision ID: a082711d385e
Revises: 35d6835fbaf8
Create Date: 2024-11-01 09:57:38.234749

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'a082711d385e'
down_revision = '35d6835fbaf8'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('bed_entry', schema=None) as batch_op:
        batch_op.add_column(sa.Column('warning', sa.String(length=255), nullable=True))

    with op.batch_alter_table('bed_file', schema=None) as batch_op:
        batch_op.add_column(sa.Column('warning', sa.Text(), nullable=True))

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('bed_file', schema=None) as batch_op:
        batch_op.drop_column('warning')

    with op.batch_alter_table('bed_entry', schema=None) as batch_op:
        batch_op.drop_column('warning')

    # ### end Alembic commands ###
</file>

<file path="migrations/versions/b42377b4f699_add_utr_settings_for_bed_types.py">
"""Add UTR settings for BED types

Revision ID: b42377b4f699
Revises: 6a06a48e6f48
Create Date: 2024-11-22 16:27:14.863339

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'b42377b4f699'
down_revision = '6a06a48e6f48'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('export_type')
    with op.batch_alter_table('settings', schema=None) as batch_op:
        batch_op.add_column(sa.Column('data_padding', sa.Integer(), nullable=True))
        batch_op.add_column(sa.Column('sambamba_padding', sa.Integer(), nullable=True))
        batch_op.add_column(sa.Column('exomeDepth_padding', sa.Integer(), nullable=True))
        batch_op.add_column(sa.Column('cnv_padding', sa.Integer(), nullable=True))

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('settings', schema=None) as batch_op:
        batch_op.drop_column('cnv_padding')
        batch_op.drop_column('exomeDepth_padding')
        batch_op.drop_column('sambamba_padding')
        batch_op.drop_column('data_padding')

    op.create_table('export_type',
    sa.Column('id', sa.INTEGER(), nullable=False),
    sa.Column('name', sa.VARCHAR(length=50), nullable=True),
    sa.Column('display_name', sa.VARCHAR(length=50), nullable=True),
    sa.Column('padding', sa.INTEGER(), nullable=True),
    sa.Column('description', sa.VARCHAR(length=200), nullable=True),
    sa.Column('button_class', sa.VARCHAR(length=50), nullable=True),
    sa.Column('icon', sa.VARCHAR(length=50), nullable=True),
    sa.Column('order', sa.INTEGER(), nullable=True),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('name')
    )
    # ### end Alembic commands ###
</file>

<file path="migrations/versions/c73425212377_update_settings_structure.py">
"""Update settings structure

Revision ID: c73425212377
Revises: b42377b4f699
Create Date: 2024-11-22 16:46:59.437781

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'c73425212377'
down_revision = 'b42377b4f699'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('settings', schema=None) as batch_op:
        batch_op.add_column(sa.Column('profile_settings', sa.JSON(), nullable=True))
        batch_op.drop_column('data_padding')
        batch_op.drop_column('cnv_padding')
        batch_op.drop_column('exomeDepth_padding')
        batch_op.drop_column('sambamba_padding')

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('settings', schema=None) as batch_op:
        batch_op.add_column(sa.Column('sambamba_padding', sa.INTEGER(), nullable=True))
        batch_op.add_column(sa.Column('exomeDepth_padding', sa.INTEGER(), nullable=True))
        batch_op.add_column(sa.Column('cnv_padding', sa.INTEGER(), nullable=True))
        batch_op.add_column(sa.Column('data_padding', sa.INTEGER(), nullable=True))
        batch_op.drop_column('profile_settings')

    # ### end Alembic commands ###
</file>

<file path="migrations/versions/ebb20169be05_change_warning_to_status_in_bedentry.py">
"""Change warning to status in BedEntry

Revision ID: ebb20169be05
Revises: 03052354c8b6
Create Date: 2024-11-26 10:35:19.059104

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'ebb20169be05'
down_revision = '03052354c8b6'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('bed_entry', schema=None) as batch_op:
        batch_op.add_column(sa.Column('status', sa.String(length=100), nullable=True))
        batch_op.drop_column('warning')
        batch_op.drop_column('mane_transcript_type')

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('bed_entry', schema=None) as batch_op:
        batch_op.add_column(sa.Column('mane_transcript_type', sa.VARCHAR(length=50), nullable=True))
        batch_op.add_column(sa.Column('warning', sa.VARCHAR(length=255), nullable=True))
        batch_op.drop_column('status')

    # ### end Alembic commands ###
</file>

<file path="migrations/alembic.ini">
# A generic, single database configuration.

[alembic]
# template used to generate migration files
# file_template = %%(rev)s_%%(slug)s

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false


# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic,flask_migrate

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[logger_flask_migrate]
level = INFO
handlers =
qualname = flask_migrate

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S
</file>

<file path="migrations/env.py">
import logging
from logging.config import fileConfig

from flask import current_app

from alembic import context

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
fileConfig(config.config_file_name)
logger = logging.getLogger('alembic.env')


def get_engine():
    try:
        # this works with Flask-SQLAlchemy<3 and Alchemical
        return current_app.extensions['migrate'].db.get_engine()
    except (TypeError, AttributeError):
        # this works with Flask-SQLAlchemy>=3
        return current_app.extensions['migrate'].db.engine


def get_engine_url():
    try:
        return get_engine().url.render_as_string(hide_password=False).replace(
            '%', '%%')
    except AttributeError:
        return str(get_engine().url).replace('%', '%%')


# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
config.set_main_option('sqlalchemy.url', get_engine_url())
target_db = current_app.extensions['migrate'].db

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def get_metadata():
    if hasattr(target_db, 'metadatas'):
        return target_db.metadatas[None]
    return target_db.metadata


def run_migrations_offline():
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url, target_metadata=get_metadata(), literal_binds=True
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online():
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """

    # this callback is used to prevent an auto-migration from being generated
    # when there are no changes to the schema
    # reference: http://alembic.zzzcomputing.com/en/latest/cookbook.html
    def process_revision_directives(context, revision, directives):
        if getattr(config.cmd_opts, 'autogenerate', False):
            script = directives[0]
            if script.upgrade_ops.is_empty():
                directives[:] = []
                logger.info('No changes in schema detected.')

    conf_args = current_app.extensions['migrate'].configure_args
    if conf_args.get("process_revision_directives") is None:
        conf_args["process_revision_directives"] = process_revision_directives

    connectable = get_engine()

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=get_metadata(),
            **conf_args
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
</file>

<file path="migrations/README">
Single-database configuration for Flask.
</file>

<file path="migrations/script.py.mako">
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision = ${repr(up_revision)}
down_revision = ${repr(down_revision)}
branch_labels = ${repr(branch_labels)}
depends_on = ${repr(depends_on)}


def upgrade():
    ${upgrades if upgrades else "pass"}


def downgrade():
    ${downgrades if downgrades else "pass"}
</file>

<file path=".dockerignore">
__pycache__
*.pyc
*.pyo
*.pyd
.Python
env
pip-log.txt
pip-delete-this-directory.txt
.tox
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.log
.git
.mypy_cache
.pytest_cache
.hypothesis
.venv
.venv/*
*.egg-info
*.egg
*.pyc
*.pyo
*.pyd
.Python
</file>

<file path=".gitignore">
.env
app/bed_generator/__pycache__/
*.pyc
*.db
transcript.db
flask_session/
env/
beds/
sort.py
logs/
check.py
sort.py
.coverage
.coverage.*
extract.py
db_data/app.db
</file>

<file path="backup.py">
import os
import shutil
from datetime import datetime
import sqlite3

def backup_database():
    """Create a backup of the SQLite database"""
    backup_dir = 'backups'
    if not os.path.exists(backup_dir):
        os.makedirs(backup_dir)
    
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    backup_path = os.path.join(backup_dir, f'app_db_backup_{timestamp}.db')
    
    # Connect to the database
    conn = sqlite3.connect('app.db')
    
    # Create a backup
    backup = sqlite3.connect(backup_path)
    conn.backup(backup)
    
    # Close connections
    backup.close()
    conn.close()
    
    # Compress backup
    shutil.make_archive(backup_path, 'gzip', backup_dir, f'app_db_backup_{timestamp}.db')
    os.remove(backup_path)
    
    # Keep only last 5 backups
    backups = sorted([f for f in os.listdir(backup_dir) if f.endswith('.gz')])
    if len(backups) > 5:
        for old_backup in backups[:-5]:
            os.remove(os.path.join(backup_dir, old_backup))

if __name__ == '__main__':
    backup_database()
</file>

<file path="config.py">
import os
from dotenv import load_dotenv

load_dotenv()  # Load environment variables from .env file

class Config:
    VERSION = '1.0.0' 
    
    # Require SECRET_KEY to be set in production
    SECRET_KEY = os.environ.get('SECRET_KEY')
    if not SECRET_KEY and os.environ.get('FLASK_ENV') == 'production':
        raise ValueError("SECRET_KEY must be set in production")
    
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or \
        'sqlite:////' + os.path.join(os.path.abspath(os.path.dirname(__file__)), 'app.db')
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    SESSION_TYPE = 'filesystem'
    DRAFT_BED_FILES_DIR = os.environ.get('DRAFT_BED_FILES_DIR') or \
        os.path.join(os.path.abspath(os.path.dirname(__file__)), 'draft_bedfiles')

class TestConfig(Config):
    TESTING = True
    SQLALCHEMY_DATABASE_URI = 'sqlite:////app/test_app.db'
    DRAFT_BED_FILES_DIR = '/app/test_draft_bedfiles'
</file>

<file path="create_user.py">
from app import create_app, db
from app.models import User

app = create_app()

def create_auth_user():
    with app.app_context():
        username = input("Enter username: ")
        email = input("Enter email: ")
        password = input("Enter password: ")
        is_authorizer = input("Make this user an authorizer? (y/n): ").lower() == 'y'

        new_user = User(username=username, email=email, is_authorizer=is_authorizer)
        new_user.set_password(password)

        db.session.add(new_user)
        db.session.commit()

        print(f"User created with id: {new_user.id}")
        print(f"Authorizer status: {'Yes' if new_user.is_authorizer else 'No'}")

if __name__ == "__main__":
    create_auth_user()
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  web:
    build: .
    command: /app/entrypoint.sh
    volumes:
      - .:/app
      - ./app.db:/app/app.db # Added to ensure data persistance
    ports:
      - "5000:5000"
    environment:
      - FLASK_APP=run.py
      - FLASK_ENV=development
      - SECRET_KEY=${SECRET_KEY}
      - DATABASE_URL=sqlite:////app/app.db
      - DRAFT_BED_FILES_DIR=/app/draft_bedfiles
    env_file:
      - .env
</file>

<file path="Dockerfile">
# Use an official Python runtime as a parent image
FROM python:3.9-slim-buster

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE 1
ENV PYTHONUNBUFFERED 1

# Set work directory
WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \
    gcc \
    libpq-dev \
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
COPY requirements.txt .
RUN pip install --upgrade pip && pip install -r requirements.txt

# Copy project
COPY . .

# Make entrypoint.sh executable
RUN chmod +x /app/entrypoint.sh

# Create a non-root user and switch to it
RUN useradd -m myuser
RUN chown -R myuser:myuser /app
USER myuser

# Run entrypoint.sh
ENTRYPOINT ["/app/entrypoint.sh"]
</file>

<file path="entrypoint.sh">
#!/bin/sh

# Initialize the database if migrations directory doesn't exist
if [ ! -d "migrations" ]; then
    echo "Initializing database..."
    flask db init
fi

# Check if there are any pending migrations
if flask db current > /dev/null 2>&1; then
    if flask db check > /dev/null 2>&1; then
        echo "No pending migrations."
    else
        echo "Running database migrations..."
        flask db migrate
        flask db upgrade
    fi
else
    echo "Running first migration..."
    flask db migrate
    flask db upgrade
fi

# Start the application
exec gunicorn -b 0.0.0.0:5000 run:app
</file>

<file path="migration.py">
"""Add UTR settings for BED types

Revision ID: <will_be_generated>
Revises: b42377b4f699
Create Date: <will_be_generated>

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '<will_be_generated>'
down_revision = 'b42377b4f699'
branch_labels = None
depends_on = None


def upgrade():
    with op.batch_alter_table('settings', schema=None) as batch_op:
        batch_op.add_column(sa.Column('data_include_5utr', sa.Boolean(), nullable=True, default=False))
        batch_op.add_column(sa.Column('data_include_3utr', sa.Boolean(), nullable=True, default=False))
        batch_op.add_column(sa.Column('sambamba_include_5utr', sa.Boolean(), nullable=True, default=False))
        batch_op.add_column(sa.Column('sambamba_include_3utr', sa.Boolean(), nullable=True, default=False))
        batch_op.add_column(sa.Column('exomeDepth_include_5utr', sa.Boolean(), nullable=True, default=False))
        batch_op.add_column(sa.Column('exomeDepth_include_3utr', sa.Boolean(), nullable=True, default=False))
        batch_op.add_column(sa.Column('cnv_include_5utr', sa.Boolean(), nullable=True, default=False))
        batch_op.add_column(sa.Column('cnv_include_3utr', sa.Boolean(), nullable=True, default=False))


def downgrade():
    with op.batch_alter_table('settings', schema=None) as batch_op:
        batch_op.drop_column('cnv_include_3utr')
        batch_op.drop_column('cnv_include_5utr')
        batch_op.drop_column('exomeDepth_include_3utr')
        batch_op.drop_column('exomeDepth_include_5utr')
        batch_op.drop_column('sambamba_include_3utr')
        batch_op.drop_column('sambamba_include_5utr')
        batch_op.drop_column('data_include_3utr')
        batch_op.drop_column('data_include_5utr')
</file>

<file path="README.md">
# BEDmaker GUI 

BEDmaker GUI is a web-based tool developed by the Synnovis Bioinformatics teams at Guy's and St Thomas' NHS Foundation Trust. It allows users to generate BED (Browser Extensible Data) files using the [Ensembl Tark](https://tark.ensembl.org/) and [VEP](https://rest.ensembl.org/#VEP) RESTful APIs.

- **Gene Symbols and Transcript IDs**: When users input gene symbols or transcript IDs, the BED File Generator queries the Tark API to retrieve the corresponding transcript data, including exon boundaries and other relevant information.
- **rsIDs and Genomic Coordinates**: For rsIDs and specific genomic coordinates, the tools uses the VEP API to fetch detailed variant annotations and their genomic positions.


## Screenshots

<div align="center" style="margin-top: 20px; padding-top: 20px;">
    <img src="app/static/images/screenshot1.png" alt="Screenshot 1 of BED File Generator" width="80%"><br></br>
    <figcaption style="text-align: center; font-size: 0.9em; color: #6c757d;">Figure 1: User interface of the BED File Generator showing the input form.</figcaption><br></br>
    <img src="app/static/images/screenshot2.png" alt="Screenshot 2 of BED File Generator" width="80%"><br></br>
    <figcaption style="text-align: center; font-size: 0.9em; color: #6c757d;">Figure 2: Results viewer displaying generated BED file data with options for customisation and download.</figcaption>
</div>

## Features

- Generate BED files from:
    - Gene symbols
    - Transcript IDs
    - rsIDs
    - Genomic coordinates
- Support for both GRCh37 (hg19) and GRCh38 (hg38) genome assemblies
- Integration with PanelApp for importing gene lists from predefined panels
- Custom padding to gene regions
- UTRs inclusion/exclusion
- Interactive results view with IGV (Integrative Genomics Viewer) integration
- User customisable BED file output in various formats (.bed, .data, .sambamba, .exomeDepth, .CNV)
- User authentication and authorisation system

## Functionality schema

<div align="center">
    <img src="app/static/images/mermaid.svg" alt="BED File Generator functionality schema" width="40%">
</div>

## Prerequisites

- Python 3.9+
- Flask
- SQLite3
- Docker (optional, for containerized deployment)

## Installation

1. Clone the repository:
   ```
   git clone <repository_url>
   cd bed-file-generator
   ```

2. Set up a virtual environment:
   ```
   python -m venv venv
   source venv/bin/activate  # On Windows, use `venv\Scripts\activate`
   ```

3. Install the required packages:
   ```
   pip install -r requirements.txt
   ```

4. Set up environment variables:
   Create a `.env` file in the project root and add the following:
   ```
   BED_GENERATOR_FLASK_KEY=<your_secret_key>
   DATABASE_URL=sqlite:///instance/transcript.db
   ```

5. Initialize the database:
   ```
   flask db init
   flask db migrate
   flask db upgrade
   ```

6. Create an initial admin user:
   ```
   python create_user.py
   ```

## Running the Application

### Development Mode

Run the following command:
```
flask run
```

The application will be available at `http://localhost:5000`.

### Production Mode

For production deployment, it's recommended to use Gunicorn:
```
gunicorn -b 0.0.0.0:5000 run:app
```

### Docker Deployment

1. Build the Docker image:
   ```
   docker build -t bed-file-generator:1.0.0 .
   ```

2. Run the container:
   ```
   docker run -p 5000:5000 -e BED_GENERATOR_FLASK_KEY=<your_secret_key> bed-file-generator:1.0.0
   ```

Alternatively, use Docker Compose:
```
docker-compose up
```

## Usage

1. Navigate to the application in your web browser.
2. Log in using your credentials.
3. Use the BED Generator form to input gene symbols, rsIDs, or coordinates.
4. Select the desired genome assembly and adjust settings as needed.
5. Generate the BED file and review the results in the interactive viewer.
6. Download the BED file in your preferred format or submit it for review.

## Project Structure

- `app/`: Main application package
  - `auth/`: Authentication-related modules
  - `bed_generator/`: Core BED file generation logic
  - `bed_manager/`: BED file management system
  - `templates/`: HTML templates
  - `static/`: Static files (CSS, JS, images)
- `config.py`: Configuration settings
- `create_user.py`: Script to create admin users (can also be accessed via the web app)
- `run.py`: Application entry point


## Acknowledgments

- Developed by the Synnovis Bioinformatics Team @ Guy's and St Thomas' NHS Foundation Trust (2024)
- Uses IGV.js v3.0.8 for genomic visualization
- Integrates with PanelApp v2 API
- Utilises Ensembl VEP (v113) and TARK (v1.0.1) RESTful APIs for metadata
</file>

<file path="run.py">
from app import create_app, db
from dotenv import load_dotenv
import os

load_dotenv()  # Load environment variables from .env file

app = create_app()
app.config['SEND_FILE_MAX_AGE_DEFAULT'] = 0  # Disable caching for static files

if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    app.run(debug=True)
    app.secret_key = os.getenv('SECRET_KEY')  # Load secret key from environment
</file>

</repository_files>
